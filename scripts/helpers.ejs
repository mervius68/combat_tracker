<script>
    let cellCountVertical,
        participantsHpsByRound;

    async function load_encounter(encounterCode = 0, dataNav = 1) {
        modalIsOpen = false // global variable is created

        const encounterData = await dbQuery("GET", "getEncounterID")
        const savedEncounterPlaceholder = encounterData.data.info
        try {
            document.removeEventListener("contextmenu", contextMenuListener);
        } catch (err) { }
        document.removeEventListener("keydown", keydownEventListener);
        document.removeEventListener("keydown", clickEventListener);
        cellCountVertical = 1;
        const getLatestID = await dbQuery("GET", "latest_eID");
        const latestID = getLatestID.eID;
        const encounterID = savedEncounterPlaceholder || encounterCode || latestID;
        let encounter = await dbQuery(
            "GET",
            "selected_encounter/" + encounterID
        );
        let header = document.querySelector(".main_header");

        header.textContent = `${encounter[0]?.campaign || "No available encounters yet"
            } - ${encounter[0]?.location || ""} (${encounter[0]?.description || ""
            })`;

        const originalParticipants = await dbQuery("GET", "participants/" + encounterID);
        for (participant of originalParticipants) {
            const newNames = await dbQuery("GET", "updatedNames/" + participant.pID)
            participant.character_name = newNames[0].character_name
        }

        // set ctApp to originalParticipants before using reduce method on originalParticipants
        ctApp = [...originalParticipants]
        const getEncounter = await dbQuery("GET", "getLatestEncounterID");
        if (encounterCode == 0) {
            ctAppEnc = savedEncounterPlaceholder || getEncounter.eID;
        }

        const encounteredNames = new Set();
        const duplicateNames = new Set();
        const resultArray = [];

        // Filter the array to identify duplicates
        ctApp.forEach((character) => {
            if (encounteredNames.has(character.character_name)) {
                duplicateNames.add(character.character_name);
            } else {
                encounteredNames.add(character.character_name);
            }
        });

        ctApp.forEach((character) => {
            // Check if character_name has a number in numeric_value
            const hasNumber = /\d/.test(character.numeric_value);

            // Check if character_name is not a duplicate and has a number in numeric_value
            if (!duplicateNames.has(character.character_name) && hasNumber) {
                resultArray.push(character);
            }
        });

        await handleNumericValues()

        // get all the actions of this encounter as ctActions and ctActionsConditions
        // global variables
        ctActions = await dbQuery("GET", "actions/" + encounterID);
        for (let i = 0; i < ctActions.length; i++) {
            // Assign the value of result_aID to aID
            ctActions[i].aID = ctActions[i].result_aID;
            ctActions[i].eID = ctActions[i].result_eID;
            ctActions[i].pID = ctActions[i].result_pID;
        }
        ctActionsConditions = await dbQuery("GET", "actionsConditions/" + encounterID)

        function mergeArrays(mainArray, secondaryArray) {
            // Create a map of objects in the secondary array using aID as the key
            const secondaryMap = new Map();
            for (const obj of secondaryArray) {
                secondaryMap.set(obj.aID, obj);
            }

            // Iterate through the main array and add properties from the secondary array
            for (const obj of mainArray) {
                const matchingObj = secondaryMap.get(obj.aID);
                if (matchingObj) {
                    // Merge properties from matchingObj into obj
                    Object.assign(obj, matchingObj);
                }
            }
            return mainArray;
        }

        // merge actions and conditions, as ctActions
        ctActions = mergeArrays(ctActions, ctActionsConditions);

        // get all the conditions of this encounter
        let ctConditions = await dbQuery(
            "GET",
            "getConditionsForCtApp/" + encounterID
        );

        // determine how many rounds are represented in the database
        // for this encounter
        let totalRounds = ctActions.reduce((max, obj) => {
            return obj.round > max ? obj.round : max;
        }, -Infinity);

        // calculate # of rounds
        let ct_damages = await dbQuery("GET", "damages/" + encounterID);
        let damageRounds = 1;
        try {
            damageRounds =
                ct_damages?.reduce((max, obj) => {
                    return obj.round > max.round ? obj : max;
                }).round || 1;
        } catch (err) { }

        // get participants hps by round
        participantsHpsByRound = await dbQuery(
            "GET",
            "hpsByRound/" + encounterID
        );

        // build the damageArray property for each participant; sub-arrays represent rounds
        ctApp.forEach((participant) => {
            participant.damageArray = [];
            for (let i = 0; i < damageRounds; i++) {
                participant.damageArray[i] = [];
                if (Array.isArray(participant.damageArray[i - 1])) {
                    participant.damageArray[i].push(
                        participant.damageArray[i - 1][
                        participant.damageArray[i - 1].length - 1
                        ]
                    );
                } else {
                    participant.damageArray[i].push(participant.starting_hp);
                }
                let x = participantsHpsByRound.filter((target) => {
                    return (
                        target.round == i + 1 &&
                        target.target_pID == participant.pID
                    );
                });
                x.forEach((item) => {
                    if (item.target_pID == participant.pID) {
                        participant.damageArray[i].push(item.new_hp);
                    }
                });
                participant.damageArray = participant.damageArray.map((arr) => {
                    return arr.filter((num, i) => {
                        return i === 0 || num !== arr[i - 1];
                    });
                });
            }
        });

        // build a conditionsArray and affectedArray properties for the participant
        ctApp.forEach((participant) => {
            participant.conditionsArray = [];
            participant.affectedArray = [];
            ctConditions.forEach((condition) => {
                if (condition.pID == participant.pID) {
                    participant.conditionsArray.push(condition);
                }
                let affectedArray = [];
                if (condition.affected_pID == participant.pID) {
                    participant.affectedArray.push(condition);
                }
                participant.conditionsArray =
                    participant.conditionsArray.filter(
                        (obj, index, self) =>
                            index ===
                            self.findIndex(
                                (t) => t.conditionID === obj.conditionID
                            )
                    );
            });
        });
        totalRounds = Math.max(totalRounds, damageRounds);

        // start a loop to build each round
        let mainContainer = document.createElement("div");
        for (let i = 1; i <= totalRounds + 1; i++) {

            // build the wireframe of first section (participants);
            const ctRound = document.createElement("div");
            ctRound.classList.add("ct_round");
            ctRound.setAttribute("data-round", i);

            const section1 = document.createElement("div");
            section1.classList.add("ct_grid4columns");
            section1.setAttribute("data-section", "1");

            const div1 = document.createElement("div");
            div1.classList.add("section");
            div1.classList.add("header");
            div1.classList.add("ct_turn_bookends");
            div1.classList.add("center");
            div1.textContent = "AC";
            const div2 = document.createElement("div");
            div2.classList.add("section");
            div2.classList.add("header");
            div2.classList.add("ct_turn_bookends");
            div2.classList.add("center");
            div2.textContent = "HP";
            const div3 = document.createElement("div");
            div3.classList.add("section");
            div3.classList.add("header");
            div3.classList.add("ct_turn_bookends");
            div3.classList.add("center");
            div3.textContent = "Character";
            const div4 = document.createElement("div");
            div4.classList.add("section");
            div4.classList.add("header");
            div4.classList.add("ct_turn_bookends");
            div4.classList.add("center");
            div4.textContent = "Init";

            section1.appendChild(div1);
            section1.appendChild(div4);
            section1.appendChild(div3);
            section1.appendChild(div2);

            ctRound.appendChild(section1);
            mainContainer.appendChild(ctRound);

            for (let j = 0; j <= ctApp.length - 1; j++) {
                let div5 = document.createElement("div");
                div5.classList.add("section");
                div5.classList.add("ct_turn_bookends");
                div5.classList.add("center");
                div5.classList.add("pointer");
                div5.setAttribute("data-participant", ctApp[j].pID);
                div5.setAttribute("data-nav", cellCountVertical);
                div5.setAttribute("tabindex", cellCountVertical);
                div5.setAttribute("data-round", i);
                div5.classList.add("delete_character")
                cellCountVertical += 1;
                let div6 = document.createElement("div");
                div6.classList.add("section");
                div6.classList.add("ct_turn_bookends");
                div6.classList.add("center");
                let div7 = document.createElement("div");
                div7.classList.add("section");
                div7.classList.add("ct_turn_bookends");
                div7.classList.add("center");
                let div8 = document.createElement("div");
                div8.classList.add("section");
                div8.classList.add("ct_turn_bookends");
                div8.classList.add("center");
                section1.appendChild(div5);
                section1.appendChild(div6);
                section1.appendChild(div7);
                section1.appendChild(div8);
            }
            ctRound.appendChild(section1);

            // how many attack, bonus, and react sections are needed for this round?
            const filterActionsByType = (ctActions, ctApp, actionType, round) =>
                ctApp.map((participant) =>
                    ctActions.filter((action) =>
                        action.pID === participant.pID &&
                        action.action_type === actionType &&
                        action.round === round
                    )
                );

            let attacksThisRound = filterActionsByType(ctActions, ctApp, "attack", i);
            let numAttacks = Math.max(findLargestSubarray(attacksThisRound), 1);

            let bonusThisRound = filterActionsByType(ctActions, ctApp, "bonus", i);
            let bonusActions = findLargestSubarray(bonusThisRound);

            let reactThisRound = filterActionsByType(ctActions, ctApp, "react", i);
            let reactActions = findLargestSubarray(reactThisRound);

            // build the attack section(s), empty; we'll fill 'em up at the end of the loop
            let sectionHTML = buildASection(
                "attack",
                ctRound,
                numAttacks,
                ctApp
            );
            mainContainer.appendChild(sectionHTML);

            // build the bonus section if there is one, empty.
            sectionHTML = buildASection(
                "bonus",
                ctRound,
                bonusActions,
                ctApp
            );
            mainContainer.appendChild(sectionHTML);

            // build the reaction section if there is one, empty
            sectionHTML = buildASection(
                "react",
                ctRound,
                reactActions,
                ctApp
            );
            mainContainer.appendChild(sectionHTML);

            // build the final section, empty
            const section2 = document.createElement("div");
            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-section", 2);

            const div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add("ct_turn_bookends");
            div5.classList.add("center");
            div5.textContent = "Drop";
            const div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add("ct_turn_bookends");
            div6.classList.add("align_left");
            div6.textContent = "Start";
            const div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add("ct_turn_bookends");
            div7.classList.add("align_right");
            div7.textContent = "End";
            const div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add("ct_turn_bookends");
            div8.classList.add("center");
            div8.textContent = "Notes";

            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);

            ctApp.forEach((participant) => {
                const div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add("ct_turn_bookends");
                div9.classList.add("center");
                div9.setAttribute("div-participant", participant.pID);
                const div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add("ct_turn_bookends");
                div10.classList.add("align_left");
                const div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add("ct_turn_bookends");
                div11.classList.add("align_right");
                const div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add("ct_turn_bookends");
                div12.classList.add("center");

                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
            });
            ctRound.appendChild(section2);

            mainContainer.appendChild(ctRound);
            const headerText = document.createElement("h2");
            headerText.textContent =
                i == totalRounds + 1 ? "" : "Round " + (i + 1);
            mainContainer.appendChild(headerText);

            const divCM = document.createElement("div");
            divCM.classList.add("custom-cm");
            const divCM2 = document.createElement("div");
            divCM2.classList.add("custom-cm__item");
            divCM2.classList.add("cmEnd");
            divCM2.innerHTML = "End This Condition";
            // divCM2.setAttribute("onclick", "endCondition()");

            divCM.appendChild(divCM2);
            mainContainer.prepend(divCM);

            // populate the sections
            let roundActions = ctActions.filter((action) => {
                return action.round == i;
            });

            // populate participants
            let participantHTML;
            ctApp.forEach(async (participant) => {
                // find latest damage report for this user;
                // if no damages at all, apply participant's starting_hp;
                // else, if no damages for this round, check previous round
                // and so on;

                // figure out hit points by round
                let roundDamages = ct_damages.filter((item) => {
                    return (
                        item.round == i && item.target_pID == participant.pID
                    );
                });
                // sort oldest to newest, e.g. hit points cell might read 
                // "22, 15, 13" (hp descending as they take hits)
                roundDamages.sort((a, b) => a.tID - b.tID);

                // locate the HTML elements for this participant
                participantHTML = mainContainer.querySelectorAll(
                    '[data-round="' +
                    i +
                    '"] [data-section="1"] [data-participant="' +
                    participant.pID +
                    '"]'
                );

                // populate row in section 1 (ac, init, character name, and hp)
                participantHTML.forEach((turn, index) => {
                    // show AC on the combat tracker for this participant
                    turn.innerText =
                        participant.ac +
                        (participant.ac_secondary == null || participant.ac_secondary == ""
                            ? ""
                            : " / " + participant.ac_secondary);

                    // show hit points record for each character
                    let damageObjects = roundDamages.filter((item) => {
                        return item.target_pID == participant.pID;
                    });
                    let hps = "";
                    if (participant.damageArray[i - 1]) {
                        participant.damageArray[i - 1].forEach((hp, index) => {
                            hps +=
                                (hp == participant.starting_hp
                                    ? "<b>" + hp + "</b>"
                                    : hp) +
                                (index <
                                    participant.damageArray[i - 1].length - 1
                                    ? ", "
                                    : "");
                        });
                        turn.nextSibling.nextSibling.nextSibling.innerHTML = hps;
                    } else {
                        participant.damageArray[i - 2].forEach((hp, index) => {
                            hps =
                                (hp == participant.starting_hp
                                    ? "<b>" + hp + "</b>"
                                    : hp) +
                                (index <
                                    participant.damageArray[i - 2].length - 1
                                    ? ", "
                                    : "");
                        });
                        turn.nextSibling.nextSibling.nextSibling.innerHTML = hps;
                    }

                    // show character name
                    let characterDisplay = "";
                    if (participant.join_round <= i && participant.dead_round >= i) {
                        characterDisplay =
                            participant.character_name +
                            (["null", "", " ", "0", 0].includes(participant.numeric_value)
                                ? ""
                                : " #" + participant.numeric_value);
                    } else {
                        let span6 = document.createElement("span");
                        span6.classList.add("participantGray");
                        span6.innerHTML = participant.character_name +
                            (participant.numeric_value == null
                                ? ""
                                : " #" + participant.numeric_value);
                        characterDisplay = span6.outerHTML;
                    }
                    turn.nextSibling.nextSibling.innerHTML = characterDisplay;

                    // if character has a condition/concentration, show icon with tooltip
                    participant.conditionsArray.forEach(async (condition) => {
                        let affecteesStill = await dbQuery(
                            "GET",
                            "anyoneStillAffected/" +
                            condition.conditionID +
                            "/" +
                            i
                        );

                        const maxValue = Math.max(
                            ...affecteesStill.map((obj) => obj.end_round)
                        );
                        const maxObjects = affecteesStill.filter(
                            (obj) => obj.end_round === maxValue
                        );

                        let affectedThisRound = ctApp.filter((item) =>
                            affecteesStill.some(
                                (obj) => obj.affected_pID === item.pID
                            )
                        );
                        let endRound = maxObjects[0]?.end_round;

                        let affectedInitLower = false;
                        if (
                            affectedThisRound.some(
                                (item) => item.init < participant.init
                            )
                        ) {
                            affectedInitLower = true;
                        }

                        let matchingObject = null;

                        // Iterate over the values array in reverse order
                        for (let i = ctApp.length - 1; i >= 0; i--) {
                            const value = ctApp[i].pID;

                            // Find the first object that matches the current value
                            matchingObject = ctApp.find(
                                (obj) => obj.pID === value
                            );

                            // If a matching object is found, exit the loop
                            if (matchingObject) {
                                break;
                            }
                        }

                        if (
                            ((parseInt(condition.concentration) == 1 || parseInt(condition.holding) == 1) &&
                                parseInt(condition.start_round) <= i &&
                                parseInt(endRound) >= i &&
                                affectedInitLower == true) ||
                            ((parseInt(condition.concentration) == 1 || parseInt(condition.holding) == 1) &&
                                parseInt(condition.start_round) <= i &&
                                parseInt(endRound) >= i &&
                                affectedInitLower == false)
                        ) {
                            // get the participants who are affected by this condition.taID
                            let affectees = await dbQuery(
                                "GET",
                                "getAffectees/" + condition.taID + "/" + i
                            );
                            let affecteesString = "";
                            affectees.forEach((affectee, index) => {
                                affecteesString +=
                                    affectee.character_name +
                                    (affectee.numeric_value
                                        ? " #" + affectee.numeric_value
                                        : "") +
                                    (index != affectees.length - 1 ? ", " : "");
                            });

                            let toolTipHTML = document.createElement("span");
                            toolTipHTML.classList.add("tooltip");
                            toolTipHTML.classList.add("concentration");
                            toolTipHTML.setAttribute(
                                "data-condition-id",
                                condition.conditionID
                            );
                            toolTipHTML.setAttribute(
                                "data-affected-id",
                                condition.affected_pID
                            );
                            toolTipHTML.setAttribute(
                                "data-taid",
                                condition.taID
                            );
                            toolTipHTML.setAttribute(
                                "data-causerID",
                                condition.pID
                            );

                            toolTipHTML.setAttribute("data-this-round", i);
                            if (parseInt(condition.concentration) == 1) {
                                toolTipHTML.innerText = "C";
                            } else if (parseInt(condition.holding) == 1) {
                                toolTipHTML.innerText = "H";
                                // let x = document.querySelector("[data-participant='64'][data-round='1'][data-nav]");
                                // x.nextSibling.nextSibling.innerText += "H";
                            }
                            toolTipHTML.classList.add("hovertwin");
                            toolTipHTML.setAttribute("data-hover-id", condition.taID);
                            let toolTipText = document.createElement("span");
                            toolTipText.classList.add("tooltiptext");
                            toolTipText.innerHTML =
                                condition.description.toUpperCase() +
                                "<br><br>" +
                                participant.character_name +
                                (participant.numeric_value
                                    ? " #" + participant.numeric_value
                                    : "") +
                                " <span class='arrow-container'></span> " +
                                affecteesString;
                            toolTipHTML.appendChild(toolTipText);

                            // try {
                            //     let x = document.querySelector("[data-participant='64'][data-round='1'][data-nav]");
                            //     x.nextSibling.nextSibling.innerHTML += toolTipHTML.outerHTML;
                            // }
                            // catch(err) {
                            turn.nextSibling.nextSibling.innerHTML +=
                                toolTipHTML.outerHTML;
                            // }

                        }
                    });

                    // if participant is affected by a condition, show icon with tooltip
                    participant.affectedArray.forEach((affected) => {
                        const affectedParticipant = ctApp.find(
                            (participant) => participant.pID === affected.pID
                        );
                        let endPosition = ctApp.findIndex((item) => {
                            return item.pID == affected.end_pID;
                        });
                        let causerPosition = ctApp.findIndex((item) => {
                            return item.pID == affected.pID;
                        });
                        let affectedPosition = ctApp.findIndex((item) => {
                            return item.pID == affected.affected_pID;
                        });

                        const affectedInit = affectedParticipant?.init;
                        if (
                            affected.concentration === 0
                                ? affected.pID !=
                                parseInt(affected.affected_pID)
                                : affected.concentration === 1 &&
                                parseInt(affected.start_round) <= i &&
                                parseInt(affected.end_round) >= i
                        ) {
                            let starter = parseInt(affected.start_round);
                            let stopper = parseInt(affected.end_round);

                            if (starter < i && stopper > i) {
                                populateAffected();
                            } else if (
                                affectedPosition == endPosition &&
                                affectedPosition < causerPosition &&
                                starter == i
                            ) {
                            } else if (
                                endPosition <= affectedPosition &&
                                ((starter == i && stopper > i) ||
                                    (endPosition == affectedPosition &&
                                        stopper == i))
                            ) {
                                populateAffected();
                            } else if (
                                affectedPosition <= causerPosition &&
                                starter < i &&
                                stopper == i
                            ) {
                                populateAffected();
                            } else if (
                                causerPosition < affectedPosition &&
                                affectedPosition <= endPosition
                            ) {
                                if (starter == i && stopper == i) {
                                    populateAffected();
                                } else if (starter < i && stopper == i) {
                                    populateAffected();
                                } else if (starter == i && stopper > i) {
                                    populateAffected();
                                }
                            }

                            function populateAffected() {
                                const toolTipHTML =
                                    document.createElement("span");
                                toolTipHTML.classList.add("tooltip");
                                toolTipHTML.classList.add("affected");
                                toolTipHTML.setAttribute(
                                    "data-condition-id",
                                    affected.conditionID
                                );
                                toolTipHTML.setAttribute(
                                    "data-affected-id",
                                    affected.affected_pID
                                );
                                toolTipHTML.setAttribute("data-this-round", i);
                                toolTipHTML.innerHTML = "A";
                                toolTipHTML.classList.add("hovertwin")
                                toolTipHTML.setAttribute(
                                    "data-taid",
                                    affected.taID
                                );
                                toolTipHTML.setAttribute(
                                    "data-hover-id",
                                    affected.taID
                                );
                                let span5 = document.createElement("span");
                                span5.classList.add("tooltiptext");
                                span5.innerHTML =
                                    affected.description +
                                    "<br><br>" +
                                    ctApp.find((participant) => {
                                        return affected.pID == participant.pID;
                                    }).character_name +
                                    (ctApp.find((participant) => {
                                        return affected.pID == participant.pID;
                                    }).numeric_value
                                        ? " #" +
                                        ctApp.find((participant) => {
                                            return (
                                                affected.pID ==
                                                participant.pID
                                            );
                                        }).numeric_value
                                        : "") +
                                    " <span class='arrow-container'></span> " +
                                    participant.character_name +
                                    (participant.numeric_value
                                        ? " #" + participant.numeric_value
                                        : "");
                                toolTipHTML.appendChild(span5);
                                turn.nextSibling.nextSibling.appendChild(
                                    toolTipHTML
                                );
                            }
                        }
                    });

                    // show initiative value for this character
                    turn.nextSibling.innerText =
                        participant.init;
                });

                // does the row deserve a yellow or red highlight (e.g. 50% hp or 0 hp)
                participantHTML.forEach(async (turn, index) => {
                    let newValue = turn.nextSibling.nextSibling.nextSibling.innerText.split(",");
                    // if newValue contains comma, get what's to the right of the last comma
                    // const arr = previousHP.nextSibling.innerHTML.split(","); // split the string into an array based on comma delimiter
                    const lastNum = newValue.pop().trim(); // remove and return the last element of the array, and trim any whitespace
                    let x =
                        turn.nextSibling.nextSibling.querySelectorAll(
                            ".affected"
                        );
                    // compare that value to participant.max_hp
                    if (lastNum <= participant.max_hp / 2) {
                        turn.classList.add("yellow");
                        turn.nextSibling.classList.add("yellow");
                        turn.nextSibling.nextSibling.classList.add("yellow");
                        turn.nextSibling.nextSibling.nextSibling.classList.add(
                            "yellow"
                        );
                    }
                    if (lastNum <= 0) {
                        turn.classList.add("red");
                        turn.nextSibling.classList.add("red");
                        turn.nextSibling.nextSibling.classList.add("red");
                        x.forEach((y) => {
                            y.parentNode.removeChild(y);
                        });
                        turn.nextSibling.nextSibling.nextSibling.classList.add(
                            "red"
                        );
                    }
                });
            });
        }

        // load the actions into the wireframe
        try {
            for (const action of ctActions) {
                let tool = {};
                if (action.toolID) {
                    tool = await dbQuery("GET", "tool/" + action.toolID);
                    tool = tool[0].toolName;
                } else {
                    tool = action.action;
                }
                let target = {};
                if (action.targetID) {
                    target = await dbQuery("GET", "target/" + action.targetID);
                }

                let targets,
                    targetString = "",
                    damageString = "";
                try {
                    targets = await dbQuery(
                        "GET",
                        "targets/" + target[0].targetID
                    );
                    targetString = "";
                    damageString = "";
                    targets.forEach((item, index) => {
                        targetString +=
                            (index > 0 ? " / " : "") +
                            item.character_name +
                            (item.numeric_value
                                ? " #" + item.numeric_value
                                : "");
                        damageString += (index > 0 ? " / " : "") + item.damage;
                    });
                } catch (err) { }

                let actionObject = {};
                actionObject.tool = tool || "";
                actionObject.hit =
                    action.hit == 1 ? "<b>âœ…</b>" : "";
                actionObject.targetName = targetString || "";
                actionObject.damage = damageString || "";
                actionObject.notes = action.notes || "";
                actionObject.end = action.end_note || "";
                actionObject.start = action.start_note || "";
                actionObject.aID = action.result_aID || "";

                await sendToCoordinate(
                    action.round,
                    action.pID,
                    action.action_type || "",
                    actionObject,
                    action.taID || "0"
                );
            }
        } catch (err) { }

        // size the sections
        document.querySelector(".ct_round_container").innerHTML =
            mainContainer.innerHTML;
        resizeSections();

        // assign background colors to show selected line
        let startNav = document.querySelector(`[data-nav="${dataNav}"]`);
        try {
            startNav.classList.add("selected");
            startNav.nextSibling.classList.add("selected");
            startNav.nextSibling.nextSibling.classList.add("selected");
            startNav.nextSibling.nextSibling.nextSibling.classList.add(
                "selected"
            );
            navify();
        } catch (err) { }

        // function to populate the individual actions
        function sendToCoordinate(round, participant, actionType, actionObject, taID) {
            try {
                let y = mainContainer.querySelector(
                    `[data-round="${round}"] [data-section="2"] [div-participant="${participant}"]`
                );
                let y_drop = y;
                let y_start = y.nextSibling;
                let y_notes = y.nextSibling.nextSibling.nextSibling
                let y_end = y.nextSibling.nextSibling;

                if (
                    (actionObject.notes && actionObject.notes != "-")
                ) {
                    y_notes.innerHTML =
                        y.nextSibling.nextSibling.nextSibling.innerHTML +
                        (y.nextSibling.nextSibling.nextSibling.innerHTML == ""
                            ? ""
                            : " | ") +
                        `<span class="notes" data-aid=${actionObject.aID}>${actionObject.notes}</span>` +
                        " ";
                }

                if (actionObject.start && actionObject.start != "-") {
                    y_start.innerHTML = actionObject.start;
                }

                if (actionObject.end && actionObject.end != "-") {
                    y_end.innerHTML = actionObject.end;
                }

                if (actionObject.drop && actionObject.drop != "-") {
                    y_drop.innerHTML = actionObject.drop;
                }
            } catch (err) { }

            let actionHTML = "data-" + actionType;
            let action = 1;
            let x;
            try {
                do {
                    x = mainContainer.querySelector(
                        `[data-round="${round}"] [${actionHTML}="${action}"] [data-participant="${participant}"]`
                    );
                    action += 1;
                } while (x.innerHTML !== "");
                if (taID != "0") {
                    x.classList.add("hovertwin");
                    x.setAttribute("data-hover-id", taID || "0")
                }
                x.innerHTML = `<span data-aid=${actionObject.aID}>${actionObject.tool}</span>`;
                x.nextSibling.innerHTML = actionObject.hit
                x.nextSibling.nextSibling.innerHTML = actionObject.targetName;
                x.nextSibling.nextSibling.nextSibling.innerHTML =
                    actionObject.damage;


            } catch (err) { }
        }

        let xyz;
        try {
            xyz = document.querySelectorAll(".ct_round");
            xyz[xyz.length - 1].classList.add("hidden");
            xyz[xyz.length - 1].classList.add("sometimes_hidden");
            xyz[xyz.length - 1].previousSibling.classList.add("hidden");
            xyz[xyz.length - 1].previousSibling.classList.add("sometimes_hidden");
            startNav.parentNode.parentNode.classList.remove("hidden");
            startNav.parentNode.parentNode.previousSibling.classList.remove(
                "hidden"
            );
        }
        catch (err) { }


        const cm = document.querySelector(".custom-cm");

        const contextMenuListener = function (e) {
            e.preventDefault();
            const element = e.target;
            const dataAidValue = element.dataset.aid;
            const contextMenu = document.querySelector(".custom-cm__item")
            contextMenu.innerText = "";
            if (element.classList.contains("affected") || element.classList.contains("concentration")) {
                const scrollLeft =
                    window.pageXOffset || document.documentElement.scrollLeft;
                const scrollTop =
                    window.pageYOffset || document.documentElement.scrollTop;
                const menuHeight = cm.offsetHeight;
                const menuWidth = cm.offsetWidth;
                const clickY = e.clientY + scrollTop;
                const clickX = e.clientX + scrollLeft;
                const maxY = window.innerHeight + scrollTop;
                const maxX = window.innerWidth + scrollLeft;

                const top = clickY + menuHeight > maxY ? maxY - menuHeight : clickY;
                const left = clickX + menuWidth > maxX ? maxX - menuWidth : clickX;

                contextMenu.innerHTML = "Stop Condition Here";
                contextMenu.setAttribute("onclick", "endCondition()");

                let cmEnd = document.querySelector(".cmEnd");
                cmEnd.setAttribute(
                    "data-cm-condition-id",
                    element.getAttribute("data-condition-id")
                );
                cmEnd.setAttribute(
                    "data-cm-causer-id",
                    element.getAttribute("data-causerID")
                );
                cmEnd.setAttribute(
                    "data-cm-affected-id",
                    element.getAttribute("data-affected-id")
                );
                cmEnd.setAttribute(
                    "data-cm-taid",
                    element.getAttribute("data-taid")
                );
                cmEnd.setAttribute(
                    "data-cm-round",
                    element.getAttribute("data-this-round")
                );
                cmEnd.setAttribute(
                    "data-cm-concentration-or-affected",
                    element.classList.contains("affected")
                        ? "affected"
                        : "concentration"
                );
                showContextMenu()
            }
            else if ((element.classList.contains("attack") || element.classList.contains("attack_alt") || element.parentElement.classList.contains("attack") || element.parentElement.classList.contains("attack_alt")) && element.innerText !== "" && (element.hasAttribute("data-participant") || element.parentElement.hasAttribute("data-participant"))) {
                const editAction = document.createElement("div");
                editAction.classList.add("clickable_area")
                editAction.classList.add("context_div");
                editAction.textContent = "Edit Action";
                editAction.addEventListener("click", () => updateAction(dataAidValue));

                const deleteActionEl = document.createElement("div");
                deleteActionEl.classList.add("clickable_area")
                deleteActionEl.classList.add("context_div");
                deleteActionEl.textContent = "Delete Action";
                deleteActionEl.addEventListener("click", () => deleteAction(dataAidValue));

                contextMenu.appendChild(editAction);
                const br = document.createElement("br");
                // contextMenu.appendChild(br);
                contextMenu.appendChild(deleteActionEl);
                showContextMenu()
            }
            else if ((element.classList.contains("bonus") || element.parentElement.classList.contains("bonus")) && element.innerText !== "") {
                const editAction = document.createElement("div");
                editAction.classList.add("clickable_area")
                editAction.classList.add("context_div");
                editAction.textContent = "Edit Action";
                editAction.addEventListener("click", () => updateAction(dataAidValue));

                const deleteBonusActionEl = document.createElement("div");
                deleteBonusActionEl.innerHTML = "Delete Action";
                deleteBonusActionEl.classList.add("context_div")
                deleteBonusActionEl.addEventListener("click", () => deleteAction(dataAidValue));

                contextMenu.appendChild(editAction);
                contextMenu.appendChild(deleteBonusActionEl)
                showContextMenu()
            }
            else if ((element.classList.contains("react") || element.parentElement.classList.contains("react")) && element.innerText !== "") {
                const editAction = document.createElement("div");
                // editAction.classList.add("clickable_area")
                editAction.classList.add("context_div");
                editAction.textContent = "Edit Action";
                editAction.addEventListener("click", () => updateAction(dataAidValue));

                const deleteReactionEl = document.createElement("div");
                deleteReactionEl.classList.add("context_div")
                deleteReactionEl.innerHTML = "Delete Reaction";
                deleteReactionEl.addEventListener("click", () => deleteAction(dataAidValue));

                contextMenu.appendChild(editAction);
                contextMenu.appendChild(deleteReactionEl)
                showContextMenu()
            }
            else if (element.classList.contains("notes") && element.innerText !== "") {
                const editAction = document.createElement("div");
                editAction.classList.add("context_div");
                editAction.textContent = "Edit Action";
                editAction.addEventListener("click", () => updateAction(dataAidValue));

                const deleteOption = document.createElement("div");
                deleteOption.classList.add("context_div");
                deleteOption.textContent = "Delete Note";
                deleteOption.addEventListener("click", () => deleteNote(dataAidValue));

                contextMenu.appendChild(editAction);
                contextMenu.appendChild(deleteOption);
                showContextMenu()
            }
            else if (element.classList.contains("delete_character") && element.innerText !== "") {
                const characterToAdjustInit = element.getAttribute("data-participant")
                const divAdjustInit = document.createElement("div");
                divAdjustInit.classList.add("context_div");
                divAdjustInit.textContent = "Adjust Initiative";
                divAdjustInit.addEventListener("click", () => adjustInitModal(characterToAdjustInit));

                const characterToAdjustHP = element.getAttribute("data-participant")
                const divAdjustHP = document.createElement("div");
                divAdjustHP.classList.add("context_div");
                divAdjustHP.textContent = "Adjust Starting HP";
                divAdjustHP.addEventListener("click", (e) => adjustHPModal(e, characterToAdjustHP));

                const characterToDelete = element.getAttribute("data-participant")
                const deleteCharacter = document.createElement("div");
                deleteCharacter.classList.add("context_div");
                deleteCharacter.textContent = "Delete Character";
                deleteCharacter.addEventListener("click", () => deleteParticipant(characterToDelete));

                const br = document.createElement("br");
                const br2 = document.createElement("br");
                contextMenu.appendChild(divAdjustInit);
                // contextMenu.appendChild(br);
                contextMenu.appendChild(divAdjustHP);
                // contextMenu.appendChild(br2);
                contextMenu.appendChild(deleteCharacter);
                showContextMenu();
            }
            else {
                console.log(e.target.outerHTML)
            }

        };

        function showContextMenu(show = true) {
            cm.style.display = show ? "block" : "none";

            // Adjust for scroll position
            const scrollX = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft;
            const scrollY = window.scrollY || window.pageYOffset || document.documentElement.scrollTop;

            cm.style.left = event.clientX + scrollX + "px";
            cm.style.top = event.clientY + scrollY + "px";
        }

        window.addEventListener("click", () => {
            showContextMenu(false);
        });

        const keyupEventListener = (e) => {
            const modal = document.querySelector(".modal");
            if (e.key === "Escape" && modalIsOpen) {
                modal.style.display = "none";
                modalIsOpen = false;
            } else if (e.key === "Enter") {
                if (!modalIsOpen) {
                    e.altKey ? launchConditionsModal("turn") : launchActionModal("turn");
                } else {
                    const modalType = modal.querySelector(".modal-body").getAttribute("data-modal-type");
                    if (modalType === "action") {
                        submitAction();
                    } else if (modalType === "condition") {
                        submitCondition();
                    }
                    modalIsOpen = false;
                    document.removeEventListener("keyup", keyupEventListener);
                }
            }
        }

        document.addEventListener("keyup", keyupEventListener);
        document.addEventListener("contextmenu", contextMenuListener);

        // fill values for dropdown
        // fillDropdown(encounterCode);
        fillInitDropdown();
        fillEncounterDropdown();

        // Get all elements with the specified data-hover-id attribute
        const elements = document.querySelectorAll('[data-hover-id]');

        // Attach hover event listeners to each element
        elements.forEach(element => {
            element.addEventListener('mouseenter', handleMouseEnter);
            element.addEventListener('mouseleave', handleMouseLeave);
        });

        function handleMouseEnter(event) {
            // Get the data-hover-id attribute value of the current element
            const hoverId = event.target.getAttribute('data-hover-id');

            // Find all elements with the same data-hover-id attribute
            const twinElements = document.querySelectorAll(`[data-hover-id="${hoverId}"]`);

            // Apply the hover effect to all twin elements
            twinElements.forEach(twinElement => {
                twinElement.classList.add('hovered');
            });
        }

        function handleMouseLeave(event) {
            // Get the data-hover-id attribute value of the current element
            const hoverId = event.target.getAttribute('data-hover-id');

            // Find all elements with the same data-hover-id attribute
            const twinElements = document.querySelectorAll(`[data-hover-id="${hoverId}"]`);

            // Remove the hover effect from all twin elements
            twinElements.forEach(twinElement => {
                twinElement.classList.remove('hovered');
            });
        }
    }

    async function adjustInitModal(characterToAdjustInit) {
        const pIDObject = ctApp.find(obj => obj.pID == characterToAdjustInit);

        const modal = document.querySelector("#modal-body");

        const container = document.createElement("div");
        container.classList.add("modal-body");
        let div = document.createElement("div");
        div.classList.add("modal-content");
        let h1 = document.createElement("h1");
        h1.classList.add("center");
        h1.innerText = "INITIATIVE FOR " + pIDObject.character_name + ((pIDObject.numeric_value) ? " #" + pIDObject.numeric_value : "");
        div.appendChild(h1);

        // html
        // div containing first line: rolled d20
        const rolledD20Div = document.createElement("div");
        rolledD20Div.classList.add("line");
        const rolledD20Input = document.createElement("input");
        rolledD20Input.setAttribute("type", "text");
        rolledD20Input.setAttribute("id", "rolledD20")
        rolledD20Input.classList.add("initValues");
        rolledD20Input.setAttribute("maxLength", "2");
        rolledD20Input.setAttribute("data-init-rolled-pid", pIDObject.pID);
        rolledD20Input.defaultValue = parseInt(pIDObject.init) - parseInt(pIDObject.init_modifier);
        const rolledD20Label = document.createElement("label")
        rolledD20Label.setAttribute("for", "rolledD20");
        rolledD20Label.innerText = "Rolled d20";
        rolledD20Div.appendChild(rolledD20Input);
        rolledD20Div.appendChild(rolledD20Label)

        // div containing DEX modifier info
        const modifierDiv = document.createElement("div");
        modifierDiv.classList.add("line");
        const modifierText = document.createElement("span");
        modifierText.innerText = (pIDObject.init_modifier > -1 ? "+" : "") + pIDObject.init_modifier;
        const modifierTextDesc = document.createElement("span");
        modifierTextDesc.innerText = " DEX Modifier";
        modifierDiv.appendChild(modifierText);
        modifierDiv.appendChild(modifierTextDesc);

        // div containing third line (d20 plus modifier)
        const initDiv = document.createElement("div");
        initDiv.classList.add("line");
        const initInput = document.createElement("input");
        initInput.setAttribute("type", "text");
        initInput.setAttribute("id", "initValue")
        initInput.classList.add("initValues");
        initInput.setAttribute("maxLength", "2");
        initInput.setAttribute("data-init-pid", pIDObject.pID);
        initInput.defaultValue = parseInt(pIDObject.init);
        const initLabel = document.createElement("label")
        initLabel.setAttribute("for", "initValue");
        initLabel.innerText = "Adjusted Initiative";
        initDiv.appendChild(initInput);
        initDiv.appendChild(initLabel);

        // div containing 4th line (secondary init);
        const secondaryInitDiv = document.createElement("div");
        secondaryInitDiv.classList.add("line");
        const secondaryInitInput = document.createElement("input");
        secondaryInitInput.setAttribute("type", "text");
        secondaryInitInput.setAttribute("id", "secondaryInit")
        secondaryInitInput.classList.add("initValues");
        secondaryInitInput.setAttribute("maxLength", "2");
        secondaryInitInput.setAttribute("data-init-secondary-pid", pIDObject.pID);
        secondaryInitInput.defaultValue = pIDObject.secondary_init;
        const secondaryInitLabel = document.createElement("label")
        secondaryInitLabel.setAttribute("for", "secondaryInit");
        secondaryInitLabel.innerText = "Secondary Initiative";
        secondaryInitDiv.appendChild(secondaryInitInput);
        secondaryInitDiv.appendChild(secondaryInitLabel)

        const div4 = document.createElement("div");
        div4.classList.add("center-div-align-left");
        div4.appendChild(rolledD20Div);
        div4.appendChild(modifierDiv);
        div4.appendChild(initDiv);
        div4.appendChild(secondaryInitDiv);


        div.appendChild(div4)
        container.appendChild(div);

        const br = document.createElement("br");
        container.appendChild(br);
        const br2 = document.createElement("br");

        const button = document.createElement("button");
        button.setAttribute("onclick", "submitAdjustInit()")
        button.innerText = "SUBMIT";
        button.classList.add("center")

        const button2 = document.createElement("button");
        button2.setAttribute("onclick", "closeModal()")
        button2.innerText = "CLOSE";
        button2.classList.add("close-modal")
        button2.classList.add("center");

        let div3 = document.createElement("div");
        div3.classList.add("center")

        div3.appendChild(button)
        div3.appendChild(button2)
        container.appendChild(div3);
        container.appendChild(br2);

        modal.innerHTML = container.outerHTML;
        setTimeout(() => {
            let cursorField = document.querySelector('input[data-init-pid]')
            cursorField.focus();
        }, 90)

        modal.addEventListener("input", function (e) {
            if (e.target.getAttribute("id") == "initValue") {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                modal.querySelector("#rolledD20").value = modal.querySelector("#initValue").value - (pIDObject.init_modifier || 0);
            } else if (e.target.getAttribute("id") == "rolledD20") {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                modal.querySelector("#initValue").value = (parseInt(modal.querySelector("#rolledD20").value) + parseInt(pIDObject.init_modifier || 0)) || pIDObject.init_modifier;
            }
        });

        const cm = document.querySelector(".modal-content");
        function showContextMenu(show = true) {
            cm.style.display = show ? "block" : "none";
        }
        pushModal();
        modalIsOpen = true;
    }

    async function submitAdjustInit() {
        // get new initiative and pID
        const newInitEle = document.querySelector("#initValue")
        const newInit = newInitEle.value;
        const pID = newInitEle.getAttribute("data-init-pid")
        // get secondary initiative
        const newSecondaryInit = document.querySelector("#secondaryInit").value

        const data = {
            init: newInit,
            secondary_init: newSecondaryInit,
            pID: pID
        }

        // submit to database
        await dbQueryPost("adjustInit", data)
        refresh_encounter()
        closeModal()
    }

    async function adjustHPModal(e, characterToAdjustHP) {
        // alert(e.target.outerHTML)
        const pIDObject = ctApp.find(obj => obj.pID == characterToAdjustHP);
        const modal = document.querySelector("#modal-body");

        const container = document.createElement("div");
        container.classList.add("modal-body");
        let div = document.createElement("div");
        div.classList.add("modal-content");
        let h1 = document.createElement("h1");
        h1.classList.add("center");
        h1.innerText = "ADJUST Starting Hit Points FOR " + pIDObject.character_name + ((pIDObject.numeric_value) ? " #" + pIDObject.numeric_value : "");
        div.appendChild(h1);

        const div2 = document.createElement("div");
        div2.classList.add("center-div-align-left");

        // div containing given Max HP info
        const changeHPDiv = document.createElement("div");
        changeHPDiv.classList.add("line");
        const maxHPSpan = document.createElement("span");
        maxHPSpan.innerText = pIDObject.max_hp;
        const maxHPDesc = document.createElement("span");
        maxHPDesc.innerText = " Max HP";
        changeHPDiv.appendChild(maxHPSpan);
        changeHPDiv.appendChild(maxHPDesc);
        div2.appendChild(changeHPDiv);

        // div containing new HP input
        const startingHPDiv = document.createElement("div");
        startingHPDiv.classList.add("line");
        const startingHPInput = document.createElement("input");
        startingHPInput.setAttribute("type", "text");
        startingHPInput.setAttribute("id", "startingHP")
        startingHPInput.classList.add("startingHP");
        startingHPInput.setAttribute("maxLength", "2");
        startingHPInput.setAttribute("data-starting-hp-pid", pIDObject.pID);
        // startingHPInput.defaultValue = pIDObject.max_hp;
        const startingHPLabel = document.createElement("label")
        startingHPLabel.setAttribute("for", "startingHP");
        startingHPLabel.innerHTML = "&nbsp;&nbsp;&nbsp;Starting HP";
        startingHPDiv.appendChild(startingHPInput);
        startingHPDiv.appendChild(startingHPLabel)
        div2.appendChild(startingHPDiv)

        const br = document.createElement("br");
        const br2 = document.createElement("br");
        const br3 = document.createElement("br");

        const button = document.createElement("button");
        button.setAttribute("onclick", `submitAdjustHP(${pIDObject.pID})`)
        button.innerText = "SUBMIT";
        button.classList.add("center")

        const button2 = document.createElement("button");
        button2.setAttribute("onclick", "closeModal()")
        button2.innerText = "CLOSE";
        button2.classList.add("close-modal")
        button2.classList.add("center");

        let div3 = document.createElement("div");
        div3.classList.add("center")

        div3.appendChild(button)
        div3.appendChild(button2)

        container.appendChild(div);
        container.appendChild(div2);
        container.appendChild(br);
        container.appendChild(br2);
        container.appendChild(div3);
        container.appendChild(br3);


        modal.innerHTML = container.outerHTML;
        setTimeout(() => {
            let cursorField = document.querySelector('input[data-starting-hp-pid]')
            cursorField.focus();
        }, 90)

        const cm = document.querySelector(".modal-content");
        function showContextMenu(show = true) {
            cm.style.display = show ? "block" : "none";
        }
        pushModal();
        modalIsOpen = true;
    }

    async function submitAdjustHP(characterToAdjustHP) {
        const startingHPEle = document.querySelector("#startingHP")
        const starting_hp = startingHPEle.value;
        const pIDObject = ctApp.find(obj => obj.pID == characterToAdjustHP);
        const pID = pIDObject.pID;
        const max_hp = pIDObject.max_hp;

        const data = {
            pID: pID,
            max_hp: max_hp,
            starting_hp: starting_hp
        }

        await dbQueryPost("submitStartingHP", data)
        refresh_encounter()
        closeModal()

    }

    async function updateAction(dataAidValue) {
        const aIDObject = ctActions.find(obj => obj.aID == dataAidValue);
        const targetsArray = await dbQuery("GET", `targets/${aIDObject.targetID}`)

        // Example usage
        const targetIDToRetrieve = aIDObject.targetID;
        const actionObj = getCombinedObjectByTargetID(targetIDToRetrieve);
        xxx = actionObj
        let modal = document.querySelector("#modal-body");
        let html = document.querySelector(".selected");
        let dataNavSelected = html.getAttribute("data-nav");

        let participantID = actionObj.ct_tbl_action.pID// html.getAttribute("data-participant");
        let characterID = ctApp.find((participant) => {
            return participant.pID == participantID;
        }).chID;
        let currentRound = actionObj.ct_tbl_action.round // html.getAttribute("data-round");
        let encounter = ctApp[0].eID;

        // get participant's info
        // tools
        let participantTools = await dbQuery(
            "GET",
            "participantTools/" + characterID
        );
        // targets
        let allParticipants = ctApp.filter((participant) => {
            return participant// (
        });
        // conditions in effect (with option to end them)
        let conditionsInEffect = await dbQuery(
            "GET",
            "conditionsInEffect/" + encounter + "/" + currentRound
        );
        // build the HTML
        let container = document.createElement("div");
        container.setAttribute("data-modal-type", "action")
        container.classList.add("modal-body");

        let h3 = document.createElement("h3");
        let character = ctApp.find((participant) => {
            return participant.pID == participantID;
        });
        h3.innerHTML =
            character.character_name +
            (character.numeric_value ? " #" + character.numeric_value : "");
        container.appendChild(h3);

        let divModalTop = document.createElement("div");
        divModalTop.classList.add("flex_horizontal");

        let divLeft = document.createElement("div");
        divLeft.classList.add("flex-left");

        // load weapons/tools
        let div13 = document.createElement("div");
        let div1Title = document.createElement("h3");
        div1Title.classList.add("left");
        div1Title.innerHTML = "Weapons/Tools";
        div13.appendChild(div1Title);

        let div14 = document.createElement("div");
        let defaultTool = document.createElement("input");
        defaultTool.setAttribute("type", "radio");
        defaultTool.setAttribute("value", 0);
        defaultTool.setAttribute("id", "default");
        defaultTool.setAttribute("name", "weapons");
        defaultTool.classList.add("pointer");
        defaultTool.setAttribute("data-concentration", 0);
        defaultTool.setAttribute("checked", "true");
        let defaultLabel = document.createElement("label");
        defaultLabel.setAttribute("for", "default");
        defaultLabel.classList.add("radio_buttons");
        defaultLabel.innerHTML = "NONE";
        defaultLabel.classList.add("pointer");
        if (actionObj.ct_tbl_action.action == "none") {
            defaultLabel.setAttribute("checked", "checked");
        }
        let br1 = document.createElement("br");
        div14.appendChild(defaultTool);
        div14.appendChild(defaultLabel);
        div14.appendChild(br1);
        // const targetPID = 60; // Specify the target pID
        for (item of participantTools) {
            let tool = document.createElement("input");
            tool.setAttribute("type", "radio");
            tool.setAttribute("value", item.toolName);
            tool.setAttribute("id", item.toolID);
            tool.classList.add("pointer");
            tool.setAttribute("name", "weapons");
            tool.setAttribute("data-concentration", item.concentration);
            tool.setAttribute("data-holding", item.holding);
            tool.setAttribute("data-holding-one-round", item.holding_one_round);
            try {
                if (item.toolID == actionObj.ct_tbl_action.toolID) {
                    tool.setAttribute("checked", "checked");
                    tool.setAttribute("data-condition-id", aIDObject.conditionID)
                }
            }
            catch (err) { }

            let label = document.createElement("label");
            label.setAttribute("for", item.toolID);
            label.classList.add("radio_buttons");
            label.classList.add("pointer");
            label.innerHTML =
                item.toolName +
                (item.damage_dice ? " (" + item.damage_dice + ")" : "");
            let span4;
            if (item.holding == 1) {
                span4 = document.createElement("span");
                span4.innerHTML = "H";
                span4.classList.add("holding");
                label.appendChild(span4);
            }
            let span1;
            if (item.concentration == "1") {
                span1 = document.createElement("span");
                span1.innerHTML = "C";
                span1.classList.add("concentration");
                label.appendChild(span1);
            }
            let br = document.createElement("br");
            div14.appendChild(tool);
            div14.appendChild(label);
            div14.appendChild(br);
        };

        divLeft.appendChild(div13);

        const actionsArray = [
            "dash",
            "disarm",
            "disengage",
            "dodge",
            "escape",
            "grapple",
            "help",
            "hide",
            "improvise",
            "ready",
            "search",
            "shove",
            "use an object",
        ];

        let weaponTextInput = document.createElement("input");
        weaponTextInput.setAttribute("type", "text");
        weaponTextInput.setAttribute("name", "weaponTextInput");
        weaponTextInput.setAttribute("autocomplete", "off");
        weaponTextInput.classList.add("text_field");
        if (actionObj.ct_tbl_action.toolID != NaN
            && actionObj.ct_tbl_action.toolID != ""
            && !actionObj.ct_tbl_action.toolID > 0
            && actionObj.ct_tbl_action.action != "none"
            && !actionsArray.includes(actionObj.ct_tbl_action.action)
        ) {
            weaponTextInput.defaultValue = actionObj.ct_tbl_action.action
        }
        let label1 = document.createElement("label");
        let br2 = document.createElement("br");

        div14.appendChild(weaponTextInput);
        div14.appendChild(label1);
        div14.appendChild(br2);
        divLeft.appendChild(div14);
        divModalTop.appendChild(divLeft);

        let divMiddleLeft = document.createElement("div");
        divMiddleLeft.classList.add("modal_column");
        let anotherDiv = document.createElement("div");

        actionsArray.forEach((action) => {
            let actionsRadio = document.createElement("input");
            actionsRadio.setAttribute("type", "radio");
            actionsRadio.setAttribute("value", action);
            actionsRadio.setAttribute("id", action);
            actionsRadio.classList.add("pointer");
            actionsRadio.setAttribute("name", "weapons");
            actionsRadio.setAttribute(
                "data-holding",
                action == "grapple" ||
                    action == "disarm" ||
                    action == "help" ||
                    action == "ready" ||
                    action == "shove"
                    ? 1
                    : 0
            );
            actionsRadio.setAttribute(
                "data-holding-one-round",
                action == "help" || action == "ready" ? 1 : 0
            );
            if (actionObj.ct_tbl_action.action == action) {
                actionsRadio.setAttribute("checked", "checked");
            }
            let label = document.createElement("label");
            label.setAttribute("for", action);
            label.classList.add("pointer");
            label.classList.add("radio_buttons");
            label.innerHTML = action;
            let span2;
            if (
                action == "grapple" ||
                action == "disarm" ||
                action == "help" ||
                action == "ready" ||
                action == "shove"
            ) {
                span2 = document.createElement("span");
                span2.innerHTML = "H";
                span2.classList.add("holding");
                label.appendChild(span2);
            }
            let br = document.createElement("br");
            anotherDiv.appendChild(actionsRadio);
            anotherDiv.appendChild(label);
            anotherDiv.appendChild(br);
        });

        divMiddleLeft.appendChild(anotherDiv);
        divModalTop.appendChild(divMiddleLeft);

        let divMiddleRight = document.createElement("div");
        divMiddleRight.classList.add("modal_column");
        let anotherDiv2 = document.createElement("div");
        anotherDiv2.classList.add("modal_column_int");
        let actionCategories = ["action", "bonus", "reaction", "other"];

        actionCategories.forEach((action) => {
            let actionsRadio = document.createElement("input");
            actionsRadio.setAttribute("type", "radio");
            actionsRadio.setAttribute(
                "value",
                action == "reaction" ? "react" : action
            );
            if (action == "action") {
                actionsRadio.setAttribute("checked", "true");
            }
            actionsRadio.setAttribute(
                "id",
                action == "reaction" ? "react" : action
            );
            actionsRadio.setAttribute("name", "actions");
            actionsRadio.classList.add("pointer");
            if (actionObj.ct_tbl_action.action_type == action || (actionObj.ct_tbl_action.action_type == "react" && action == "reaction")) {
                actionsRadio.setAttribute("checked", "checked");
            } else if (actionObj.ct_tbl_action.action_type == action) {
                actionsRadio.setAttribute("checked", "checked");

            }
            let label = document.createElement("label");
            label.setAttribute("for", action == "reaction" ? "react" : action);
            label.classList.add("radio_buttons");
            label.classList.add("pointer");
            label.innerHTML = action;
            let br = document.createElement("br");
            anotherDiv2.appendChild(actionsRadio);
            anotherDiv2.appendChild(label);
            anotherDiv2.appendChild(br);
        });

        divMiddleRight.appendChild(anotherDiv2);
        divModalTop.appendChild(divMiddleRight);

        let divRight = document.createElement("div");
        divRight.classList.add("flex-right");

        let div15 = document.createElement("h3");
        div15.innerHTML = "Targets / Damage/HP";
        divRight.appendChild(div15);
        let div16 = document.createElement("div");
        div16.classList.add("conSaveParent");

        // populate the targets of the modal
        // first determine, by data-nav position, which targets to eliminate from list
        let redHTMLElements = document.querySelectorAll(".red.pointer");
        let redHTML = Array.from(redHTMLElements);
        let redAfterSelection = redHTML.filter((item) => {
            return parseInt(item.getAttribute("data-nav")) < parseInt(dataNavSelected) + ctApp.length
        })
        let redAfterSelectionParticipants = [];
        redAfterSelection.forEach((item) => {
            redAfterSelectionParticipants.push(parseInt(item.getAttribute("data-participant")))
        })
        allParticipants.forEach((participant) => {
            // const newArray = targetsArray.filter((item) => {
            //     return item.target_pID == 
            // })
            let target = document.createElement("input");
            target.setAttribute("type", "text");
            actionObj.ct_tbl_target[0].forEach((targetParticipant) => {
                if (targetParticipant.pID == participant.pID) {
                    target.defaultValue = targetParticipant.damage
                    target.setAttribute("data-stored-damage", targetParticipant.damage)
                } else {
                    target.setAttribute("data-stored-damage", 0)
                }
                if (targetParticipant.pID == participant.pID && targetParticipant.damage == 0) {
                    target.defaultValue = "x"
                    target.setAttribute("data-stored-damage", 0)
                }

            })
            target.classList.add("text_field");
            target.classList.add("numeric");
            target.setAttribute("name", "participants");
            target.setAttribute("id", "p" + participant.pID);
            target.setAttribute("data-pid", participant.pID);
            target.setAttribute("autocomplete", "off");

            let targetLabel = document.createElement("label");
            targetLabel.setAttribute("for", "p" + participant.pID);
            targetLabel.classList.add("p" + participant.pID);
            targetLabel.classList.add("modal_text_inputs");
            if (redAfterSelectionParticipants.includes(participant.pID)) {
                targetLabel.classList.add("downed-participants")
            }
            if (character.pc != participant.pc) {
                targetLabel.classList.add("bold-target")
            }
            targetLabel.classList.add("pointer");
            targetLabel.innerHTML =
                participant.character_name +
                (participant.numeric_value
                    ? " #" + participant.numeric_value
                    : "");

            let br3 = document.createElement("br");
            div16.appendChild(target);
            div16.appendChild(targetLabel);

            div16.appendChild(br3);

        });

        divRight.appendChild(div16);

        const notesLabel = document.createElement("h3");
        notesLabel.innerText = "Notes";
        const notes = document.createElement("textarea");
        let defaultNotesValue = actionObj.ct_tbl_action.notes == "-" ? "" : actionObj.ct_tbl_action.notes;
        defaultNotesValue = defaultNotesValue
            .replace("&quest;", "?") // question mark
            .replace("&apos;", "'")  // apostrophe
        notes.defaultValue = defaultNotesValue;
        notes.setAttribute("rows", "5");
        notes.setAttribute("cols", "30");
        notes.setAttribute("name", "notes");
        notes.classList.add("notes_text");

        const notesLabelStart = document.createElement("h3");
        notesLabelStart.innerText = "Start";
        const notesStart = document.createElement("textarea");
        notesStart.setAttribute("rows", "1");
        notesStart.setAttribute("cols", "30");
        notesStart.setAttribute("name", "notes_start");
        notesStart.classList.add("notes_text");

        let notesLabelEnd = document.createElement("h3");
        notesLabelEnd.innerText = "End";
        let notesEnd = document.createElement("textarea");
        notesEnd.setAttribute("rows", "1");
        notesEnd.setAttribute("cols", "30");
        notesEnd.setAttribute("name", "notes_end");
        notesEnd.classList.add("notes_text");

        divRight.appendChild(notesLabel);
        divRight.appendChild(notes);
        // divRight.appendChild(notesLabelStart);
        // divRight.appendChild(notesStart);
        // divRight.appendChild(notesLabelEnd);
        // divRight.appendChild(notesEnd);

        divModalTop.appendChild(divRight);
        container.appendChild(divModalTop);

        let divModalBottom = document.createElement("div");
        divModalBottom.classList.add("horizontal_bottom");
        let hr = document.createElement("hr");
        container.appendChild(hr);

        // TURN THIS BACK ON????
        // conditionsInEffect = conditionsInEffect.filter(
        //     (obj, index, self) =>
        //         index ===
        //         self.findIndex((t) => t.conditionID === obj.conditionID)
        // );
        conditionsInEffect.forEach((condition) => {

            if (condition.end_round == currentRound && condition.end_pID == participantID) {

            } else {
                let conditionParticipant = condition.pID;
                let startHTML = document.querySelector(
                    '[data-round="' +
                    condition.start_round +
                    '"] [data-section="1"] [data-participant="' +
                    condition.pID +
                    '"]'
                );
                let start = startHTML.getAttribute("data-nav");

                let endHTML = document.querySelector(
                    '[data-round="' +
                    condition.end_round +
                    '"] [data-section="1"] [data-participant="' +
                    condition.end_pID +
                    '"]'
                );
                let end =
                    endHTML instanceof Element
                        ? endHTML.getAttribute("data-nav")
                        : "1000";

                if (
                    parseInt(dataNavSelected) >= parseInt(start) &&
                    parseInt(dataNavSelected) <= parseInt(end)
                ) {
                    let checkbox = document.createElement("input");
                    checkbox.setAttribute("type", "checkbox");
                    checkbox.setAttribute("name", "conditions");
                    checkbox.setAttribute(
                        "data-participant-affected",
                        condition.affected_pID
                    );
                    checkbox.setAttribute("data-cpid", condition.taID);
                    checkbox.classList.add("pointer");
                    checkbox.setAttribute("id", "b" + condition.affected_pID);
                    let span = document.createElement("span");
                    if (condition.concentration == 1) {
                        span.textContent = "C";
                        span.classList.add("concentration");
                        span.classList.add("savingThrow");
                    }
                    if (condition.holding == 1) {
                        span.textContent = "H";
                        span.classList.add("holding");
                        // span.classList.add("savingThrow");
                    }
                    let label = document.createElement("label");
                    label.setAttribute("for", "b" + condition.affected_pID);
                    label.classList.add("pointer");

                    let causer = ctApp.find((participant) => {
                        return condition.pID == participant.pID;
                    });
                    let causerName =
                        causer.character_name +
                        (causer.numeric_value != null
                            ? " #" + causer.numeric_value
                            : "");
                    if (
                        condition.pID == causer.pID &&
                        condition.concentration == 1
                    ) {
                        causerName =
                            "<span class='concentration'>" + causerName + "</span>";
                    }
                    let affected = ctApp.find((participant) => {
                        return parseInt(condition.affected_pID) == participant.pID;
                    }).character_name;
                    let numeric = ctApp.find((participant) => {
                        return parseInt(condition.affected_pID) == participant.pID;
                    }).numeric_value;

                    label.innerHTML =
                        condition.condition_name +
                        ": " +
                        causerName +
                        " => <b>" +
                        affected +
                        (numeric ? " #" + numeric : "") +
                        "</b> / " +
                        condition.description;
                    label.prepend(span);
                    let br6 = document.createElement("br");
                    divModalBottom.appendChild(checkbox);
                    divModalBottom.appendChild(label);
                    divModalBottom.appendChild(br6);
                    // if target is concentrating, put a yellow-highlighted C next to their name
                    if (
                        condition.concentration == 1 &&
                        !divRight.querySelector(
                            ".p" + condition.pID + " .concentration"
                        )
                    ) {
                        let concentrationSpan = document.createElement("span");
                        concentrationSpan.textContent = "C";
                        concentrationSpan.classList.add("concentration");
                        let html = divRight.querySelector(".p" + condition.pID);
                        html.innerHTML += concentrationSpan.outerHTML;
                    }
                }
            }


        });

        container.appendChild(divModalBottom);

        let buttonContainer = document.createElement("div");
        buttonContainer.classList.add("button_container");
        let submit = document.createElement("button");
        submit.innerText = "SUBMIT";
        submit.setAttribute("data-row", dataNavSelected)
        submit.setAttribute("data-selected-pid", participantID)
        submit.setAttribute("data-current-round", currentRound);
        submit.setAttribute("onclick", `submitUpdateAction(${dataAidValue}, ${actionObj.ct_tbl_action.pID})`);
        submit.classList.add("button");
        submit.classList.add("modalSubmit");
        // let submitGoToCondition = document.createElement("button");
        // submitGoToCondition.innerText = "SUBMIT + go to CONDITIONS";
        // submitGoToCondition.classList.add("button");
        // submitGoToCondition.setAttribute("onclick", "submitAction('1')");

        buttonContainer.appendChild(submit);
        // buttonContainer.appendChild(submitGoToCondition);
        container.appendChild(buttonContainer);

        modal.innerHTML = container.outerHTML;

        await document.removeEventListener("click", clickEventListener);
        document.addEventListener("click", clickEventListener);

        // Attach the event listener to the modal
        modal.addEventListener("click", modalClickListener);

        modal.addEventListener("input", function (e) {
            if (e.target.parentElement.classList.contains("conSaveParent")) {
                let concentrationStuff =
                    e.target.parentNode.querySelectorAll(".concentration");
                concentrationStuff.forEach((participant) => {
                    let z = participant.parentElement;
                    if (
                        participant.parentNode.previousSibling.value != "" &&
                        participant.parentNode.previousSibling.value != "0" &&
                        participant.parentNode.previousSibling.value != "00" &&
                        participant.parentNode.previousSibling.value != "000"
                    ) {
                        try {
                            let x = z.querySelector(".conSavingThrowCheck");
                            z.removeChild(x);
                        } catch (err) { }
                        let input =
                            participant.parentNode.previousSibling.value;
                        if (input / 2 <= 10) {
                            input = 10;
                        } else {
                            input = Math.floor(input / 2);
                        }
                        let span3 = document.createElement("span");
                        if (parseInt(input)) {
                            span3.classList.add("conSavingThrowCheck");
                            span3.innerHTML = `DC CON ${input}`;
                        }
                        participant.parentNode.appendChild(span3);
                    } else {
                        try {
                            let x = z.querySelector(".conSavingThrowCheck");
                            z.removeChild(x);
                        } catch (err) { }
                    }
                });
            }
        });
        const selectedWeapons = document.getElementsByName("weapons");
        selectedWeapons.forEach((weapon) => {
            if (weapon.checked == true) {
                weapon.focus();
            }
        })
        // selectedWeapons[1]?.focus()
        // selectedWeapons[0]?.removeAttribute("checked")
        // selectedWeapons[1]?.setAttribute("checked", "checked");
        modalIsOpen = true;
        pushModal();
        function findHighestAIDByPID(array, targetPID) {
            // Filter the array to include only objects with the specified pID
            const filteredArray = array.filter(item => item.pID === parseInt(targetPID) && item.toolID != null);
            // Check if there are any objects with the specified pID
            if (filteredArray.length === 0) {
                return null; // No matching objects found
            }

            // Find the object with the highest aID among those with the same pID
            const highestAIDObject = filteredArray.reduce((maxObject, currentObject) => {
                return currentObject.aID > maxObject.aID ? currentObject : maxObject;
            }, filteredArray[0]);

            return highestAIDObject;
        }
        modalIsOpen = true;

        function getCombinedObjectByTargetID(targetID) {
            const actionsArray = [aIDObject];
            const combinedObject = {};

            // Iterate over actionsArray
            actionsArray.forEach((action) => {
                const currentTargetID = action.targetID;

                // Create a new object for targetID if it doesn't exist in combinedObject
                if (!combinedObject[currentTargetID]) {
                    combinedObject[currentTargetID] = {
                        ct_tbl_action: action,
                        ct_tbl_target: [],
                    };
                }

                // Add ct_tbl_target objects to the array within the corresponding ct_tbl_action object
                combinedObject[currentTargetID].ct_tbl_target.push(
                    targetsArray.filter((target) => target.targetID === currentTargetID)
                );
            });

            // Retrieve the combinedObject for the specified targetID
            const resultForTargetID = combinedObject[targetID];
            return resultForTargetID;
        }
    }

    async function submitUpdateAction(dataAidValue, pID) {
        const data = document.querySelector(".modalSubmit");
        const dataNav = data.getAttribute("data-row");
        const currentRound = data.getAttribute("data-current-round");

        let holdingOneRound = 0;

        // determine next available targetID
        let nextTargetID = await dbQuery("GET", "getNextTargetID");
        if (nextTargetID.length > 0 && nextTargetID[0].targetID != undefined) {
            nextTargetID = nextTargetID[0].targetID + 1;
        } else {
            nextTargetID = 1;
        }

        // get weapon radio buttons
        let weaponTextInput = document.getElementsByName("weaponTextInput");
        let concentrationNext = 0;
        let holding = 0;
        let weapons,
            tool = [],
            toolNum = [],
            actionString = "",
            nextToolID = "";
        if (weaponTextInput[0].value == "") {
            weapons = document.getElementsByName("weapons");
            tool = Array.from(weapons).find((weapon) => {
                return weapon.checked == true;
            }).value // was .id, but that seemed wrong
            try {
                toolNum = Array.from(weapons).find((weapon) => {
                    return weapon.checked == true;
                }).id
            }
            catch (err) { }

            concentrationNext =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-concentration") || 0;
            holding =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-holding") || 0;
            holdingOneRound =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-holding-one-round") || 0;
            if (isNaN(parseInt(tool))) {
                actionString = tool;
                nextToolID = "0";
            } else if (tool == 0) {
                tool = "none";
                actionString = "none";
                nextToolID = "0";
            } else {
                actionString = "-";
                nextToolID = "0";
            }
        } else {
            tool = weaponTextInput[0].value;
            actionString = weaponTextInput[0].value;
            nextToolID = "0";
        }

        // determine hits and combine them into string, like "0/1" (for miss/hit)
        let targets = document.getElementsByName("participants");
        let targetHits = [];
        let target_pID = [];
        let damage = [];
        let targetHPsArray = [];
        let conditionName = actionString;
        let targetsArray = Array.from(targets);

        // wrap the forEach loop in a Promise.all
        await Promise.all(
            targetsArray.map(async (target, index) => {
                if (parseInt(target.value) && target.value != "0") {
                    targetHits.push("1 ");
                    target_pID.push(target.id.substring(1));
                    damage.push(target.value);
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                } else if (target.value == "0") {
                    targetHits.push("0 ");
                    target_pID.push(target.id.substring(1));
                    damage.push("0");
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                } else if (target.value == "x") {
                    targetHits.push("1 ");
                    target_pID.push(target.id.substring(1));
                    damage.push("0");
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                }
            })
        );
        let sortedTargetHPs = [];
        sortedTargetHPs = targetHPsArray
            .reduce((acc, obj) => {
                const key = parseInt(Object.keys(obj)[0]);
                const value = Object.values(obj)[0];
                acc.push({ key, value });
                return acc;
            }, [])
            .sort((a, b) => a.key - b.key)
            .map((obj) => obj.value);

        if (damage == "") {
            damage = "-";
        }
        if (target_pID == [""]) {
            target_pID = ["-"];
        }
        let target_pIDString = target_pID.join(",");

        if (target_pIDString == "") {
            target_pIDString = "-";
        }

        // get action type
        let actionTypeElement = document.getElementsByName("actions");
        let actionCategory = Array.from(actionTypeElement).find((item) => {
            return item.checked == true;
        }).value;
        if (actionCategory == "action") {
            actionCategory = "attack";
        }

        let notesElement = document.querySelector(".notes_text");
        let notes = notesElement.value || "-";
        notes = notes.replace("'", "&apos;").replace("#", "&num;").replace("?", "&quest;")
        if (notes == "") {
            notes = "-";
        }

        let disableConditionsEle = document.getElementsByName("conditions");
        let disableConditionsString = "";
        let disabledConditionsArray = [];

        conditionsOff = [];
        conditionsToTurnOff = {};
        conditionsData = {};
        async function processConditions() {
            for (const condition of disableConditionsEle) {
                if (condition.checked) {
                    const object = {
                        affectedpID: condition.getAttribute("data-participant-affected"),
                        condition: condition.getAttribute("data-cpid")
                    }
                    conditionsOff.push(object);           // create arrays for each condition we want to edit
                    conditionsOff.forEach((obj) => {
                        if (!conditionsToTurnOff[obj.condition]) {
                            conditionsToTurnOff[obj.condition] = [];
                            conditionsToTurnOff[obj.condition].affectees = [];
                        }
                        conditionsToTurnOff[obj.condition].affectees.push(obj.affectedpID);
                        conditionsToTurnOff[obj.condition].affectees = [...new Set(conditionsToTurnOff[obj.condition].affectees)]
                    })

                    disableConditionsString += condition.value;

                    await dbQuery(
                        "GET",
                        "disableCondition/" +
                        condition.getAttribute("data-cpid") +
                        "/" +
                        currentRound +
                        "/" +
                        condition.getAttribute(
                            "data-participant-affected"
                        ) +
                        "/" +
                        pID
                    )
                }
            }


            ctApp.forEach((participant) => {
                Object.keys(conditionsToTurnOff).forEach(async (condition) => {

                    if (!conditionsToTurnOff[condition]["condition_name"]) {
                        conditionsToTurnOff[condition]["condition_name"] = getConditionNameById(condition);
                        const creator = await ctApp.filter((participant) => {
                            return participant.pID == getCreatorById(condition);
                        });
                        conditionsToTurnOff[condition]["creator"] = creator.length > 0 ? creator[0].character_name : null;
                        conditionsToTurnOff[condition]["creator_numeric"] = creator[0].numeric_value ? creator[0].numeric_value : null;
                    }


                    function getConditionNameById(idToFind) {
                        const conditionsArray = participant.conditionsArray;
                        for (const condition of conditionsArray) {
                            if (condition.conditionID == parseInt(idToFind)) {
                                return condition.description;
                            }
                        }
                        return null; // Return null if no match is found
                    }

                    function getCreatorById(idToFind) {
                        const conditionsArray = participant.conditionsArray;
                        for (const condition of conditionsArray) {
                            if (condition.conditionID == parseInt(idToFind)) {
                                return condition.pID;
                            }
                        }
                        return null; // Return null if no match is found
                    }

                })
            })



        }
        await processConditions();
        Object.keys(conditionsToTurnOff).forEach((condition) => {
            let string = conditionsToTurnOff[condition].creator + (conditionsToTurnOff[condition].creator_numeric ? " &num;" + conditionsToTurnOff[condition].creator_numeric : "") + "&apos;s " + conditionsToTurnOff[condition].condition_name + " ends for "
            conditionsToTurnOff[condition].affectees.forEach((affectee, index) => {
                let x = ctApp.find((participant) => {
                    return participant.pID == affectee
                })
                string += index < conditionsToTurnOff[condition].affectees.length ? " [" + x.character_name + (x.numeric_value ? " &num;" + x.numeric_value : "") + "]" : ""
            })
            if (notes == "-") {
                notes = string
            } else {
                notes += " | " + string
            }
        })
        disableConditionsString = disableConditionsString || "-";

        let hit = 0;
        if (
            targetHits.find((item) => {
                return item == 1;
            })?.length >= 1
        ) {
            hit = 1;
        }
        toolNum = toolNum == "default" ? 0 : toolNum;
        toolNum = toolNum == "" ? 0 : toolNum;

        // we need to update ct_tbl_action
        /////// we may need to insert new record(s) in ct_tbl_target, if new target created
        /////// we may need to delete ct_tbl_target record(s), if target removed
        ///////////// if so, we may need to update ct_tbl_target records where ct_tbl_target.target_pID == target pID && tID > target's tID
        /////// we may need to update ct_tbl_target record(s), if target damage changed 
        // we may need to delete conditions (if one was selected originally but now NOT) 
        /////// if so, we need to delete condition_affectees
        // we may need to end conditions (below the line)
        // we may need to open conditions modal

        // determine if we need to insert a new target
        // determine if we need to delete a target
        // determine if we need to update an existing target

        // any numeric damage change to the target table will require adjustments to calculate forward

        // determine if we need to delete a condition
        // if element with data-condition-id is NOT checked,
        // delete the ct_tbl_condition record where conditionID = data-condition-id
        // delete the ct_tbl_condition_affectee records where 
        //      actionObj.ct_tbl_target.taID == ct_tbl_condition_affectee.taID

        let deleteCondition = false;

        const update = {
            ct_tbl_action: {
                update: {
                    aID: dataAidValue,
                    action: actionString,
                    action_type: actionCategory,
                    hit: hit,
                    notes: notes,
                    toolID: toolNum
                }
            },
            ct_tbl_target: {
                insert: {

                },
                update: {

                },
                delete: {

                }
            },
            ct_tbl_condition: {
                delete: {
                    aID: deleteCondtion == true ? actionObj.ct_tbl_action.aID : ""
                }
            },
            ct_tbl_condition_affectee: {
                delete: {
                    taID: deletCondition == true ? actionObj.ct_tbl_action.taID : ""
                }
            }, 
            // tbl_tool: {
            //     insert: {

            //     },
            //     delete: {

            //     }
            // }
        }

        await dbQueryPost("updateActionDB", update)

        // // let's convert damage and target_pIDString into single object:
        // // let targets = [];
        // // targets.push({
        // //      ${target_pID}: damage
        // // })

        // // is there a concentration already in effect?
        // // if so, does it end now?
        // //      if that concentration is selected from end-condition list, all good
        // //      if not, alert user that old concentration will end at this point (OK / Cancel)
        // // does a condition created by this action change?
        // // new condition, or delete condition?
        // //      delete condition => delete associated condition and condition_affectees
        // //      new condition => delete associated condition and condition_affectees 
        // //          AND create new associated condition (method from submitAction)

        // // let dataAction = `submitAction/${ctApp[0].eID}/${currentRound}/${toolNum}/${actionString}/${pID}/${nextTargetID}/${hit}/${actionCategory}/${damage}/${notes}/${disableConditionsString}/${nextAID}/${nextToolID}/${target_pIDString}`;
        // // await dbQuery("GET", dataAction);

        // let round = currentRound;
        // targetHits.forEach(async (target, index) => {
        //     if (
        //         ctApp.findIndex((participant) => {
        //             return participant.pID == pID;
        //         }) >
        //         ctApp.findIndex((target) => {
        //             return target.pID == target_pID[index];
        //         })
        //     ) {
        //         round = parseInt(currentRound) + 1;
        //     } else {
        //         round = parseInt(currentRound);
        //     }

        //     const dataTarget = `submitTargets/${ctApp[0].eID
        //         }/${round}/${tool}/${actionString}/${pID}/${nextTargetID}/${targetHits[
        //             index
        //         ].trim()}/${actionCategory}/${damage[index]
        //         }/${notes}/${disableConditionsString}/${nextAID}/${nextToolID}/${target_pID[index]
        //         }/${sortedTargetHPs[index]}`;
        //     await dbQuery("GET", dataTarget);

        //     // if a target's HP drop to zero or below...
        //     if (sortedTargetHPs[index] - damage[index] <= 0) {
        //         await dbQuery(
        //             "GET",
        //             "terminate/" + target_pID[index] + "/" + round
        //         );
        //         await dbQuery(
        //             "GET",
        //             "endConditions/" + target_pID[index] + "/" + round
        //         );
        //     } else {
        //         await dbQuery(
        //             "GET",
        //             "revive/" + target_pID[index] + "/"
        //         )
        //     }
        // });


        load_encounter(ctAppEnc, dataNav);
        let modal = document.querySelector(".modal");

        // Remove the event listener
        modal.removeEventListener("click", modalClickListener);
        modal.style.display = "none";
        if (concentrationNext == 1 || holding == 1) {
            launchConditionsModal(
                target_pID,
                concentrationNext,
                conditionName,
                holding,
                holdingOneRound,
                nextAID
            );
        }
    }

    async function modalActions() {
        let modal = document.querySelector("#modal-body");
        let html = document.querySelector(".selected");
        let dataNavSelected = html.getAttribute("data-nav");
        let participantID = html.getAttribute("data-participant");
        let characterID = ctApp.find((participant) => {
            return participant.pID == participantID;
        }).chID;
        let currentRound = html.getAttribute("data-round");
        let encounter = ctApp[0].eID;

        // get participant's info
        // tools
        let participantTools = await dbQuery(
            "GET",
            "participantTools/" + characterID
        );
        // targets
        let allParticipants = ctApp.filter((participant) => {
            return participant// (
        });
        // conditions in effect (with option to end them)
        let conditionsInEffect = await dbQuery(
            "GET",
            "conditionsInEffect/" + encounter + "/" + currentRound
        );
        // build the HTML
        let container = document.createElement("div");
        container.setAttribute("data-modal-type", "action")
        container.classList.add("modal-body");

        let h3 = document.createElement("h3");
        let character = ctApp.find((participant) => {
            return participant.pID == participantID;
        });
        h3.innerHTML =
            character.character_name +
            (character.numeric_value ? " #" + character.numeric_value : "");
        container.appendChild(h3);

        let divModalTop = document.createElement("div");
        divModalTop.classList.add("flex_horizontal");

        let divLeft = document.createElement("div");
        divLeft.classList.add("flex-left");

        // load weapons/tools
        let div13 = document.createElement("div");
        let div1Title = document.createElement("h3");
        div1Title.classList.add("left");
        div1Title.innerHTML = "Weapons/Tools";
        div13.appendChild(div1Title);

        let div14 = document.createElement("div");
        let defaultTool = document.createElement("input");
        defaultTool.setAttribute("type", "radio");
        defaultTool.setAttribute("value", 0);
        defaultTool.setAttribute("id", "default");
        defaultTool.setAttribute("name", "weapons");
        defaultTool.classList.add("pointer");
        defaultTool.setAttribute("data-concentration", 0);
        defaultTool.setAttribute("checked", "true");
        let defaultLabel = document.createElement("label");
        defaultLabel.setAttribute("for", "default");
        defaultLabel.classList.add("radio_buttons");
        defaultLabel.innerHTML = "NONE";
        defaultLabel.classList.add("pointer");
        defaultLabel.setAttribute("default", "true");
        let br1 = document.createElement("br");
        div14.appendChild(defaultTool);
        div14.appendChild(defaultLabel);
        div14.appendChild(br1);

        // const targetPID = 60; // Specify the target pID
        const resultObject = findHighestAIDByPID(ctActions, participantID);
        // participantTools.forEach((item) => {
        for (item of participantTools) {
            let tool = document.createElement("input");
            tool.setAttribute("type", "radio");
            tool.setAttribute("value", item.toolName);
            tool.setAttribute("id", item.toolID);
            tool.classList.add("pointer");
            tool.setAttribute("name", "weapons");
            tool.setAttribute("data-concentration", item.concentration);
            tool.setAttribute("data-holding", item.holding);
            tool.setAttribute("data-holding-one-round", item.holding_one_round);
            try {
                if (item.toolID == resultObject.toolID) {
                    tool.setAttribute("checked", "checked");
                }
            }
            catch (err) { }

            let label = document.createElement("label");
            label.setAttribute("for", item.toolID);
            try {
                if (item.toolID == resultObject.toolID) {
                    label.classList.add("previous_tool")
                }
            }
            catch (err) { }

            label.classList.add("radio_buttons");
            label.classList.add("pointer");
            label.innerHTML =
                item.toolName +
                (item.damage_dice ? " (" + item.damage_dice + ")" : "");
            let span4;
            if (item.holding == 1) {
                span4 = document.createElement("span");
                span4.innerHTML = "H";
                span4.classList.add("holding");
                label.appendChild(span4);
            }
            let span1;
            if (item.concentration == "1") {
                span1 = document.createElement("span");
                span1.innerHTML = "C";
                span1.classList.add("concentration");
                label.appendChild(span1);
            }
            let br = document.createElement("br");
            div14.appendChild(tool);
            div14.appendChild(label);
            div14.appendChild(br);
        };

        divLeft.appendChild(div13);

        let weaponTextInput = document.createElement("input");
        weaponTextInput.setAttribute("type", "text");
        weaponTextInput.setAttribute("name", "weaponTextInput");
        weaponTextInput.setAttribute("autocomplete", "off");
        weaponTextInput.classList.add("text_field");
        let label1 = document.createElement("label");
        let br2 = document.createElement("br");

        div14.appendChild(weaponTextInput);
        div14.appendChild(label1);
        div14.appendChild(br2);
        divLeft.appendChild(div14);
        divModalTop.appendChild(divLeft);

        let divMiddleLeft = document.createElement("div");
        divMiddleLeft.classList.add("modal_column");
        let anotherDiv = document.createElement("div");
        let actionsArray = [
            "dash",
            "disarm",
            "disengage",
            "dodge",
            "escape",
            "grapple",
            "help",
            "hide",
            "improvise",
            "ready",
            "search",
            "shove",
            "use an object",
        ];
        actionsArray.forEach((action) => {
            let actionsRadio = document.createElement("input");
            actionsRadio.setAttribute("type", "radio");
            actionsRadio.setAttribute("value", action);
            actionsRadio.setAttribute("id", action);
            actionsRadio.classList.add("pointer");
            actionsRadio.setAttribute("name", "weapons");
            actionsRadio.setAttribute(
                "data-holding",
                action == "grapple" ||
                    action == "disarm" ||
                    action == "help" ||
                    action == "ready" ||
                    action == "shove"
                    ? 1
                    : 0
            );
            actionsRadio.setAttribute(
                "data-holding-one-round",
                action == "help" || action == "ready" ? 1 : 0
            );
            let label = document.createElement("label");
            label.setAttribute("for", action);
            label.classList.add("pointer");
            label.classList.add("radio_buttons");
            label.innerHTML = action;
            let span2;
            if (
                action == "grapple" ||
                action == "disarm" ||
                action == "help" ||
                action == "ready" ||
                action == "shove"
            ) {
                span2 = document.createElement("span");
                span2.innerHTML = "H";
                span2.classList.add("holding");
                label.appendChild(span2);
            }
            let br = document.createElement("br");
            anotherDiv.appendChild(actionsRadio);
            anotherDiv.appendChild(label);
            anotherDiv.appendChild(br);
        });

        divMiddleLeft.appendChild(anotherDiv);
        divModalTop.appendChild(divMiddleLeft);

        let divMiddleRight = document.createElement("div");
        divMiddleRight.classList.add("modal_column");
        let anotherDiv2 = document.createElement("div");
        anotherDiv2.classList.add("modal_column_int");
        let actionCategories = ["action", "bonus", "reaction", "other"];

        actionCategories.forEach((action) => {
            let actionsRadio = document.createElement("input");
            actionsRadio.setAttribute("type", "radio");
            actionsRadio.setAttribute(
                "value",
                action == "reaction" ? "react" : action
            );
            if (action == "action") {
                actionsRadio.setAttribute("checked", "true");
            }
            actionsRadio.setAttribute(
                "id",
                action == "reaction" ? "react" : action
            );
            actionsRadio.setAttribute("name", "actions");
            actionsRadio.classList.add("pointer");
            let label = document.createElement("label");
            label.setAttribute("for", action == "reaction" ? "react" : action);
            label.classList.add("radio_buttons");
            label.classList.add("pointer");
            label.innerHTML = action;
            let br = document.createElement("br");
            anotherDiv2.appendChild(actionsRadio);
            anotherDiv2.appendChild(label);
            anotherDiv2.appendChild(br);
        });

        divMiddleRight.appendChild(anotherDiv2);
        divModalTop.appendChild(divMiddleRight);

        let divRight = document.createElement("div");
        divRight.classList.add("flex-right");

        let div15 = document.createElement("h3");
        div15.innerHTML = "Targets / Damage/HP";
        divRight.appendChild(div15);
        let div16 = document.createElement("div");
        div16.classList.add("conSaveParent");

        // populate the targets of the modal
        // first determine, by data-nav position, which targets to eliminate from list
        let redHTMLElements = document.querySelectorAll(".red.pointer");
        let redHTML = Array.from(redHTMLElements);
        let redAfterSelection = redHTML.filter((item) => {
            return parseInt(item.getAttribute("data-nav")) < parseInt(dataNavSelected) + ctApp.length
        })
        let redAfterSelectionParticipants = [];
        redAfterSelection.forEach((item) => {
            redAfterSelectionParticipants.push(parseInt(item.getAttribute("data-participant")))
        })
        allParticipants.forEach((participant) => {
            let target = document.createElement("input");
            target.setAttribute("type", "text");
            target.setAttribute("value", "");
            target.classList.add("text_field");
            target.classList.add("numeric");
            target.setAttribute("name", "participants");
            target.setAttribute("id", "p" + participant.pID);
            target.setAttribute("autocomplete", "off");
            let targetLabel = document.createElement("label");
            targetLabel.setAttribute("for", "p" + participant.pID);
            targetLabel.classList.add("p" + participant.pID);
            targetLabel.classList.add("modal_text_inputs");
            if (redAfterSelectionParticipants.includes(participant.pID)) {
                targetLabel.classList.add("downed-participants")
            }
            if (character.pc != participant.pc) {
                targetLabel.classList.add("bold-target")
            }
            targetLabel.classList.add("pointer");
            targetLabel.innerHTML =
                participant.character_name +
                (participant.numeric_value
                    ? " #" + participant.numeric_value
                    : "");

            let br3 = document.createElement("br");
            div16.appendChild(target);
            div16.appendChild(targetLabel);

            div16.appendChild(br3);

        });

        divRight.appendChild(div16);

        let notesLabel = document.createElement("h3");
        notesLabel.innerText = "Notes";
        let notes = document.createElement("textarea");
        notes.setAttribute("rows", "5");
        notes.setAttribute("cols", "30");
        notes.setAttribute("name", "notes");
        notes.classList.add("notes_text");

        let notesLabelStart = document.createElement("h3");
        notesLabelStart.innerText = "Start";
        let notesStart = document.createElement("textarea");
        notesStart.setAttribute("rows", "1");
        notesStart.setAttribute("cols", "30");
        notesStart.setAttribute("name", "notes_start");
        notesStart.classList.add("notes_text");

        let notesLabelEnd = document.createElement("h3");
        notesLabelEnd.innerText = "End";
        let notesEnd = document.createElement("textarea");
        notesEnd.setAttribute("rows", "1");
        notesEnd.setAttribute("cols", "30");
        notesEnd.setAttribute("name", "notes_end");
        notesEnd.classList.add("notes_text");

        divRight.appendChild(notesLabel);
        divRight.appendChild(notes);
        // divRight.appendChild(notesLabelStart);
        // divRight.appendChild(notesStart);
        // divRight.appendChild(notesLabelEnd);
        // divRight.appendChild(notesEnd);

        divModalTop.appendChild(divRight);
        container.appendChild(divModalTop);

        let divModalBottom = document.createElement("div");
        divModalBottom.classList.add("horizontal_bottom");
        let hr = document.createElement("hr");
        container.appendChild(hr);

        // TURN THIS BACK ON????
        // conditionsInEffect = conditionsInEffect.filter(
        //     (obj, index, self) =>
        //         index ===
        //         self.findIndex((t) => t.conditionID === obj.conditionID)
        // );
        qqq = conditionsInEffect;
        conditionsInEffect.forEach((condition) => {

            if (condition.end_round == currentRound && condition.end_pID == participantID) {

            } else {
                let conditionParticipant = condition.pID;
                let startHTML = document.querySelector(
                    '[data-round="' +
                    condition.start_round +
                    '"] [data-section="1"] [data-participant="' +
                    condition.pID +
                    '"]'
                );
                let start = startHTML.getAttribute("data-nav");

                let endHTML = document.querySelector(
                    '[data-round="' +
                    condition.end_round +
                    '"] [data-section="1"] [data-participant="' +
                    condition.end_pID +
                    '"]'
                );
                let end =
                    endHTML instanceof Element
                        ? endHTML.getAttribute("data-nav")
                        : "1000";

                if (
                    parseInt(dataNavSelected) >= parseInt(start) &&
                    parseInt(dataNavSelected) <= parseInt(end)
                ) {
                    let checkbox = document.createElement("input");
                    checkbox.setAttribute("type", "checkbox");
                    checkbox.setAttribute("name", "conditions");
                    checkbox.setAttribute(
                        "data-participant-affected",
                        condition.affected_pID
                    );
                    checkbox.setAttribute("data-cpid", condition.taID);
                    checkbox.classList.add("pointer");
                    checkbox.setAttribute("id", "b" + condition.affected_pID);
                    let span = document.createElement("span");
                    if (condition.concentration == 1) {
                        span.textContent = "C";
                        span.classList.add("concentration");
                        span.classList.add("savingThrow");
                    }
                    if (condition.holding == 1) {
                        span.textContent = "H";
                        span.classList.add("holding");
                        // span.classList.add("savingThrow");
                    }
                    let label = document.createElement("label");
                    label.setAttribute("for", "b" + condition.affected_pID);
                    label.classList.add("pointer");

                    let causer = ctApp.find((participant) => {
                        return condition.pID == participant.pID;
                    });
                    let causerName =
                        causer.character_name +
                        (causer.numeric_value != null
                            ? " #" + causer.numeric_value
                            : "");
                    if (
                        condition.pID == causer.pID &&
                        condition.concentration == 1
                    ) {
                        causerName =
                            "<span class='concentration'>" + causerName + "</span>";
                    }
                    let affected = ctApp.find((participant) => {
                        return parseInt(condition.affected_pID) == participant.pID;
                    }).character_name;
                    let numeric = ctApp.find((participant) => {
                        return parseInt(condition.affected_pID) == participant.pID;
                    }).numeric_value;

                    label.innerHTML =
                        condition.condition_name +
                        ": " +
                        causerName +
                        " => <b>" +
                        affected +
                        (numeric ? " #" + numeric : "") +
                        "</b> / " +
                        condition.description;
                    label.prepend(span);
                    let br6 = document.createElement("br");
                    divModalBottom.appendChild(checkbox);
                    divModalBottom.appendChild(label);
                    divModalBottom.appendChild(br6);
                    // if target is concentrating, put a yellow-highlighted C next to their name
                    if (
                        condition.concentration == 1 &&
                        !divRight.querySelector(
                            ".p" + condition.pID + " .concentration"
                        )
                    ) {
                        let concentrationSpan = document.createElement("span");
                        concentrationSpan.textContent = "C";
                        concentrationSpan.classList.add("concentration");
                        let html = divRight.querySelector(".p" + condition.pID);
                        html.innerHTML += concentrationSpan.outerHTML;
                    }
                }
            }


        });

        container.appendChild(divModalBottom);

        let buttonContainer = document.createElement("div");
        buttonContainer.classList.add("button_container");
        let submit = document.createElement("button");
        submit.innerText = "SUBMIT";
        submit.setAttribute("data-row", dataNavSelected)
        submit.setAttribute("data-selected-pid", participantID)
        submit.setAttribute("data-current-round", currentRound);
        submit.setAttribute("onclick", "submitAction()");
        submit.classList.add("button");
        submit.classList.add("modalSubmit");
        let submitGoToCondition = document.createElement("button");
        submitGoToCondition.innerText = "SUBMIT + go to CONDITIONS";
        submitGoToCondition.classList.add("button");
        submitGoToCondition.setAttribute("onclick", "submitAction('1')");

        buttonContainer.appendChild(submit);
        buttonContainer.appendChild(submitGoToCondition);
        container.appendChild(buttonContainer);

        modal.innerHTML = container.outerHTML;

        await document.removeEventListener("click", clickEventListener);
        document.addEventListener("click", clickEventListener);

        // Attach the event listener to the modal
        modal.addEventListener("click", modalClickListener);

        modal.addEventListener("input", function (e) {
            if (e.target.parentElement.classList.contains("conSaveParent")) {
                let concentrationStuff =
                    e.target.parentNode.querySelectorAll(".concentration");
                concentrationStuff.forEach((participant) => {
                    let z = participant.parentElement;
                    if (
                        participant.parentNode.previousSibling.value != "" &&
                        participant.parentNode.previousSibling.value != "0" &&
                        participant.parentNode.previousSibling.value != "00" &&
                        participant.parentNode.previousSibling.value != "000"
                    ) {
                        try {
                            let x = z.querySelector(".conSavingThrowCheck");
                            z.removeChild(x);
                        } catch (err) { }
                        let input =
                            participant.parentNode.previousSibling.value;
                        if (input / 2 <= 10) {
                            input = 10;
                        } else {
                            input = Math.floor(input / 2);
                        }
                        let span3 = document.createElement("span");
                        if (parseInt(input)) {
                            span3.classList.add("conSavingThrowCheck");
                            span3.innerHTML = `DC CON ${input}`;
                        }
                        participant.parentNode.appendChild(span3);
                    } else {
                        try {
                            let x = z.querySelector(".conSavingThrowCheck");
                            z.removeChild(x);
                        } catch (err) { }
                    }
                });
            }
        });
        const selectedWeapons = document.getElementsByName("weapons");
        selectedWeapons.forEach((weapon) => {
            if (weapon.checked == true) {
                weapon.focus();
            }
        })
        // selectedWeapons[1]?.focus()
        // selectedWeapons[0]?.removeAttribute("checked")
        // selectedWeapons[1]?.setAttribute("checked", "checked");
        modalIsOpen = true;

        function findHighestAIDByPID(array, targetPID) {
            // Filter the array to include only objects with the specified pID
            const filteredArray = array.filter(item => item.pID === parseInt(targetPID) && item.toolID != null);
            // Check if there are any objects with the specified pID
            if (filteredArray.length === 0) {
                return null; // No matching objects found
            }

            // Find the object with the highest aID among those with the same pID
            const highestAIDObject = filteredArray.reduce((maxObject, currentObject) => {
                return currentObject.aID > maxObject.aID ? currentObject : maxObject;
            }, filteredArray[0]);

            return highestAIDObject;
        }
    }

    async function submitAction(forceCondition = 0) {
        const data = document.querySelector(".modalSubmit");
        const dataNav = data.getAttribute("data-row");
        const currentRound = data.getAttribute("data-current-round");
        const pID = data.getAttribute("data-selected-pid");

        let holdingOneRound = 0;
        // determine next available action number
        let nextAID = await dbQuery("GET", "getNewAID");
        if (nextAID.length > 0 && nextAID[0].aID != undefined) {
            nextAID = nextAID[0].aID + 1;
        } else {
            nextAID = 1;
        }

        // determine next available targetID
        let nextTargetID = await dbQuery("GET", "getNextTargetID");
        if (nextTargetID.length > 0 && nextTargetID[0].targetID != undefined) {
            nextTargetID = nextTargetID[0].targetID + 1;
        } else {
            nextTargetID = 1;
        }

        // get weapon radio buttons
        let weaponTextInput = document.getElementsByName("weaponTextInput");
        let concentrationNext = 0;
        let holding = 0;
        let weapons,
            tool = [],
            toolNum = [],
            actionString = "",
            nextToolID = "";
        if (weaponTextInput[0].value == "") {
            weapons = document.getElementsByName("weapons");
            tool = Array.from(weapons).find((weapon) => {
                return weapon.checked == true;
            }).value // was .id, but that seemed wrong
            try {
                toolNum = Array.from(weapons).find((weapon) => {
                    return weapon.checked == true;
                }).id
            }
            catch (err) { }

            concentrationNext =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-concentration") || 0;
            holding =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-holding") || 0;
            holdingOneRound =
                Array.from(weapons)
                    .find((weapon) => {
                        return weapon.checked == true;
                    })
                    .getAttribute("data-holding-one-round") || 0;
            if (isNaN(parseInt(tool))) {
                actionString = tool;
                nextToolID = "0";
            } else if (tool == 0) {
                tool = "none";
                actionString = "none";
                nextToolID = "0";
            } else {
                actionString = "-";
                nextToolID = "0";
            }
        } else {
            tool = weaponTextInput[0].value;
            actionString = weaponTextInput[0].value;
            nextToolID = "0";
        }
        actionString = actionString.replace("'", "&apos;")
        // determine hits and combine them into string, like "0/1" (for miss/hit)
        let targets = document.getElementsByName("participants");
        let targetHits = [];
        let target_pID = [];
        let damage = [];
        let targetHPsArray = [];
        let conditionName = actionString;
        let targetsArray = Array.from(targets);

        // wrap the forEach loop in a Promise.all
        await Promise.all(
            targetsArray.map(async (target, index) => {
                if (parseInt(target.value) && target.value != "0") {
                    targetHits.push("1 ");
                    target_pID.push(target.id.substring(1));
                    damage.push(target.value);
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                } else if (target.value == "0") {
                    targetHits.push("0 ");
                    target_pID.push(target.id.substring(1));
                    damage.push("0");
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                } else if (target.value == "x") {
                    targetHits.push("1 ");
                    target_pID.push(target.id.substring(1));
                    damage.push("0");
                    let x = await dbQuery(
                        "GET",
                        "targetsHP/" + target.id.substring(1)
                    );
                    if (x.length > 0 && x[0].new_hp != undefined) {
                        x = x[0].new_hp;
                    } else {
                        x = ctApp.find((participant) => {
                            return participant.pID == target.id.substring(1);
                        }).starting_hp;
                    }
                    targetHPsArray.push({ [`${index}`]: x });
                }
            })
        );
        let sortedTargetHPs = [];
        sortedTargetHPs = targetHPsArray
            .reduce((acc, obj) => {
                const key = parseInt(Object.keys(obj)[0]);
                const value = Object.values(obj)[0];
                acc.push({ key, value });
                return acc;
            }, [])
            .sort((a, b) => a.key - b.key)
            .map((obj) => obj.value);

        if (damage == "") {
            damage = "-";
        }
        if (target_pID == [""]) {
            target_pID = ["-"];
        }
        let target_pIDString = target_pID.join(",");

        if (target_pIDString == "") {
            target_pIDString = "-";
        }

        // get action type
        let actionTypeElement = document.getElementsByName("actions");
        let actionCategory = Array.from(actionTypeElement).find((item) => {
            return item.checked == true;
        }).value;
        if (actionCategory == "action") {
            actionCategory = "attack";
        }

        let notesElement = document.querySelector(".notes_text");
        let notes = notesElement.value || "-";
        notes = notes.replace("'", "&apos;").replace("#", "&num;").replace("?", "&quest;")
        if (notes == "") {
            notes = "-";
        }

        let disableConditionsEle = document.getElementsByName("conditions");
        let disableConditionsString = "";
        let disabledConditionsArray = [];

        conditionsOff = [];
        conditionsToTurnOff = {};
        conditionsData = {};
        async function processConditions() {
            for (const condition of disableConditionsEle) {
                if (condition.checked) {
                    const object = {
                        affectedpID: condition.getAttribute("data-participant-affected"),
                        condition: condition.getAttribute("data-cpid")
                    }
                    conditionsOff.push(object);           // create arrays for each condition we want to edit
                    conditionsOff.forEach((obj) => {
                        if (!conditionsToTurnOff[obj.condition]) {
                            conditionsToTurnOff[obj.condition] = [];
                            conditionsToTurnOff[obj.condition].affectees = [];
                        }
                        conditionsToTurnOff[obj.condition].affectees.push(obj.affectedpID);
                        conditionsToTurnOff[obj.condition].affectees = [...new Set(conditionsToTurnOff[obj.condition].affectees)]
                    })

                    disableConditionsString += condition.value;

                    await dbQuery(
                        "GET",
                        "disableCondition/" +
                        condition.getAttribute("data-cpid") +
                        "/" +
                        currentRound +
                        "/" +
                        condition.getAttribute(
                            "data-participant-affected"
                        ) +
                        "/" +
                        pID
                    )
                }
            }


            ctApp.forEach((participant) => {
                Object.keys(conditionsToTurnOff).forEach(async (condition) => {

                    if (!conditionsToTurnOff[condition]["condition_name"]) {
                        conditionsToTurnOff[condition]["condition_name"] = getConditionNameById(condition);
                        const creator = await ctApp.filter((participant) => {
                            return participant.pID == getCreatorById(condition);
                        });
                        conditionsToTurnOff[condition]["creator"] = creator.length > 0 ? creator[0].character_name : null;
                        conditionsToTurnOff[condition]["creator_numeric"] = creator[0].numeric_value ? creator[0].numeric_value : null;
                    }


                    function getConditionNameById(idToFind) {
                        const conditionsArray = participant.conditionsArray;
                        for (const condition of conditionsArray) {
                            if (condition.conditionID == parseInt(idToFind)) {
                                return condition.description;
                            }
                        }
                        return null; // Return null if no match is found
                    }

                    function getCreatorById(idToFind) {
                        const conditionsArray = participant.conditionsArray;
                        for (const condition of conditionsArray) {
                            if (condition.conditionID == parseInt(idToFind)) {
                                return condition.pID;
                            }
                        }
                        return null; // Return null if no match is found
                    }

                })
            })



        }
        await processConditions();
        Object.keys(conditionsToTurnOff).forEach((condition) => {
            let string = conditionsToTurnOff[condition].creator + (conditionsToTurnOff[condition].creator_numeric ? " &num;" + conditionsToTurnOff[condition].creator_numeric : "") + "&apos;s " + conditionsToTurnOff[condition].condition_name + " ends for "
            conditionsToTurnOff[condition].affectees.forEach((affectee, index) => {
                let x = ctApp.find((participant) => {
                    return participant.pID == affectee
                })
                string += index < conditionsToTurnOff[condition].affectees.length ? " [" + x.character_name + (x.numeric_value ? " &num;" + x.numeric_value : "") + "]" : ""
            })
            if (notes == "-") {
                notes = string
            } else {
                notes += " | " + string
            }
        })
        disableConditionsString = disableConditionsString || "-";

        let hit = 0;
        if (
            targetHits.find((item) => {
                return item == 1;
            })?.length >= 1
        ) {
            hit = 1;
        }
        toolNum = toolNum == "default" ? 0 : toolNum;
        toolNum = toolNum == "" ? 0 : toolNum;

        let dataAction = `submitAction/${ctApp[0].eID}/${currentRound}/${toolNum}/${actionString}/${pID}/${nextTargetID}/${hit}/${actionCategory}/${damage}/${notes}/${disableConditionsString}/${nextAID}/${nextToolID}/${target_pIDString}`;
        // alert(dataAction);
        await dbQuery("GET", dataAction);

        let round = currentRound;
        targetHits.forEach(async (target, index) => {
            if (
                ctApp.findIndex((participant) => {
                    return participant.pID == pID;
                }) >
                ctApp.findIndex((target) => {
                    return target.pID == target_pID[index];
                })
            ) {
                round = parseInt(currentRound) + 1;
            } else {
                round = parseInt(currentRound);
            }

            const dataTarget = `submitTargets/${ctApp[0].eID
                }/${round}/${tool}/${actionString}/${pID}/${nextTargetID}/${targetHits[
                    index
                ].trim()}/${actionCategory}/${damage[index]
                }/${notes}/${disableConditionsString}/${nextAID}/${nextToolID}/${target_pID[index]
                }/${sortedTargetHPs[index]}`;
            await dbQuery("GET", dataTarget);
            if (sortedTargetHPs[index] - damage[index] <= 0) {
                await dbQuery(
                    "GET",
                    "terminate/" + target_pID[index] + "/" + round
                );
                await dbQuery(
                    "GET",
                    "endConditions/" + target_pID[index] + "/" + round
                );
            } else {
                await dbQuery(
                    "GET",
                    "revive/" + target_pID[index] + "/"
                )
            }
        });


        load_encounter(ctAppEnc, dataNav);
        let modal = document.querySelector(".modal");

        // Remove the event listener
        modal.removeEventListener("click", modalClickListener);
        modal.style.display = "none";
        if (concentrationNext == 1 || holding == 1 || forceCondition == 1) {
            launchConditionsModal(
                target_pID,
                concentrationNext,
                conditionName,
                holding,
                holdingOneRound,
                nextAID
            );
        }
    }

    async function modalConditions(
        affected,
        concentration,
        conditionName,
        holding,
        holdingOneRound,
        nextAID
    ) {
        let html = document.querySelector(".selected");
        let modal = document.querySelector("#modal-body");

        // let dataNavSelected = html.getAttribute("data-nav");
        let participantID = await html.getAttribute("data-participant");
        // let causerObject = ctApp.find((participant) => {
        //     return participantID == participant.pID
        // })
        // let affecteeObject = ctApp.find((participant) => {
        //     return participant.pID ==
        // })

        let characterID = ctApp.find((participant) => {
            return participant.pID == participantID;
        }).chID;

        let currentRound = html.getAttribute("data-round");
        let encounter = ctApp[0].eID;

        // get participant's info
        // tools
        let participantTools = await dbQuery(
            "GET",
            "participantTools/" + characterID
        );
        // targets

        // conditions in effect (with option to end them)
        let conditionsInEffect = await dbQuery(
            "GET",
            "conditionsInEffect/" + encounter + "/" + currentRound
        );

        // build the HTML
        let container = document.createElement("div");
        container.classList.add("container");

        let topLeftDiv = document.createElement("div");
        topLeftDiv.classList.add("topLeftDiv");

        let h2 = document.createElement("h3");
        h2.innerHTML = "Condition Causer";
        topLeftDiv.appendChild(h2);

        // build the causers radio buttons
        let causerPosition;
        ctApp.forEach((participant, index) => {
            let checkbox = document.createElement("input");
            checkbox.setAttribute("type", "radio");
            checkbox.classList.add("pointer");
            checkbox.setAttribute("name", "causers");
            checkbox.setAttribute("id", participant.pID);
            if (participantID == participant.pID) {
                checkbox.setAttribute("checked", "true");
                causerPosition = index;
            }
            let label = document.createElement("label");
            label.classList.add("pointer");
            label.setAttribute("for", participant.pID);
            label.innerHTML =
                participant.character_name +
                (participant.numeric_value
                    ? " #" + participant.numeric_value
                    : "");
            let br = document.createElement("br");

            topLeftDiv.appendChild(checkbox);
            topLeftDiv.appendChild(label);
            topLeftDiv.appendChild(br);
        });

        let topMiddleDiv = document.createElement("div");
        topMiddleDiv.classList.add("topMiddleDiv");

        let h6 = document.createElement("h3");
        h6.innerHTML = "Condition Affectee(s)";
        topMiddleDiv.appendChild(h6);
        // build the affectees checkboxes
        let affecteePosition;
        let affecteesCount = 0;
        ctApp.forEach((participant, index) => {
            let checkbox = document.createElement("input");
            checkbox.classList.add("pointer");
            checkbox.setAttribute("type", "checkbox");
            checkbox.setAttribute("name", "affectees");
            checkbox.setAttribute("id", "a" + participant.pID);
            if (affected.includes(participant.pID.toString())) {
                checkbox.setAttribute("checked", "true");
                affecteePosition = index;
                affecteesCount += 1;
            }
            let label = document.createElement("label");
            label.classList.add("pointer");
            label.setAttribute("for", "a" + participant.pID);
            label.innerHTML =
                participant.character_name +
                (participant.numeric_value
                    ? " #" + participant.numeric_value
                    : "");
            let br = document.createElement("br");

            topMiddleDiv.appendChild(checkbox);
            topMiddleDiv.appendChild(label);
            topMiddleDiv.appendChild(br);
        });

        let topRightDiv = document.createElement("div");
        topRightDiv.classList.add("topRightDiv");

        let h3 = document.createElement("h3");
        h3.innerHTML = "Whose Round It Ends On:";
        topRightDiv.appendChild(h3);

        // build the radio buttons for whose turn a condition ends on
        ctApp.forEach((participant) => {
            let checkbox = document.createElement("input");
            checkbox.setAttribute("type", "radio");
            checkbox.classList.add("pointer");
            checkbox.setAttribute("name", "condition_ends");
            checkbox.setAttribute("id", "x" + participant.pID);
            if (
                affected.includes(participant.pID.toString()) &&
                holding == 1 &&
                affecteesCount == 1
            ) {
                checkbox.setAttribute("checked", "true");
            } else {
                if (participantID == participant.pID) {
                    checkbox.setAttribute("checked", "true");
                }
            }

            let label = document.createElement("label");
            label.classList.add("pointer");
            label.setAttribute("for", "x" + participant.pID);
            label.innerHTML =
                participant.character_name +
                (participant.numeric_value
                    ? " #" + participant.numeric_value
                    : "");
            let br = document.createElement("br");

            topRightDiv.appendChild(checkbox);
            topRightDiv.appendChild(label);
            topRightDiv.appendChild(br);
        });

        container.appendChild(topLeftDiv);
        container.appendChild(topMiddleDiv);
        container.appendChild(topRightDiv);

        let div17 = document.createElement("div");
        div17.classList.add("topLeftDiv");

        let textHeader = document.createElement("h3");
        textHeader.innerHTML = "Describe the Condition";
        let textInput = document.createElement("input");
        textInput.setAttribute("type", "text");
        textInput.classList.add("conditionsText");
        textInput.setAttribute("value", conditionName || "");
        textInput.setAttribute("name", "conditionsText");
        textInput.classList.add("text_field");
        let br7 = document.createElement("br");
        div17.appendChild(textHeader);
        div17.appendChild(textInput);
        div17.appendChild(br7);

        let h7 = document.createElement("h3");
        h7.innerHTML = "Concentration Begins?";
        // let br8 = document.createElement("br");
        let radioButton1 = document.createElement("input");
        radioButton1.setAttribute("type", "radio");
        radioButton1.setAttribute("name", "concentration");
        radioButton1.setAttribute("id", "concentration_yes");
        radioButton1.classList.add("pointer");
        radioButton1.setAttribute("value", 1);
        if (concentration == 1) {
            radioButton1.setAttribute("checked", "true");
        }
        let label2 = document.createElement("label");
        label2.setAttribute("for", "concentration_yes");
        label2.classList.add("pointer");
        label2.innerText = "YES";
        let radioButton2 = document.createElement("input");
        radioButton2.setAttribute("type", "radio");
        radioButton2.setAttribute("name", "concentration");
        radioButton2.setAttribute("id", "concentration_no");
        radioButton2.classList.add("pointer");
        radioButton2.setAttribute("value", 0);
        if (radioButton1.checked == false) {
            radioButton2.setAttribute("checked", "true");
        }
        let label3 = document.createElement("label");
        label3.setAttribute("for", "concentration_no");
        label3.classList.add("pointer");
        label3.innerText = "NO";
        let br9 = document.createElement("br");

        div17.appendChild(h7);
        // div17.appendChild(br8);
        div17.appendChild(radioButton1);
        div17.appendChild(label2);
        div17.appendChild(radioButton2);
        div17.appendChild(label3);
        div17.appendChild(br9);

        let h9 = document.createElement("h3");
        h9.innerHTML = "Holding Begins?";
        // let br10 = document.createElement("br");
        let radioButton3 = document.createElement("input");
        radioButton3.setAttribute("type", "radio");
        radioButton3.setAttribute("name", "holding");
        radioButton3.setAttribute("id", "holding_yes");
        radioButton3.classList.add("pointer");
        radioButton3.setAttribute("value", 1);
        if (holding == 1) {
            radioButton3.setAttribute("checked", "true");
        }
        let label4 = document.createElement("label");
        label4.setAttribute("for", "holding_yes");
        label4.classList.add("pointer");
        label4.innerText = "YES";
        let radioButton4 = document.createElement("input");
        radioButton4.setAttribute("type", "radio");
        radioButton4.setAttribute("name", "holding");
        radioButton4.setAttribute("id", "holding_no");
        radioButton4.classList.add("pointer");
        radioButton4.setAttribute("value", 0);
        if (radioButton3.checked == false) {
            radioButton4.setAttribute("checked", "true");
        }
        let label5 = document.createElement("label");
        label5.setAttribute("for", "holding_no");
        label5.classList.add("pointer");
        label5.innerText = "NO";
        let br11 = document.createElement("br");

        div17.appendChild(h9);
        // div17.appendChild(br10);
        div17.appendChild(radioButton3);
        div17.appendChild(label4);
        div17.appendChild(radioButton4);
        div17.appendChild(label5);
        div17.appendChild(br11);

        let buttonContainer = document.createElement("div");
        buttonContainer.classList.add("button_container");
        let submit = document.createElement("button");
        submit.classList.add("pointer");
        submit.innerText = "SUBMIT";
        submit.setAttribute("onclick", `submitCondition(${nextAID})`);

        container.appendChild(div17);

        let bottomMiddleDiv = document.createElement("div");
        bottomMiddleDiv.classList.add("topRightDiv");

        let h4 = document.createElement("h3");
        h4.innerHTML = "Beginning Round";
        let beginRound = document.createElement("select");
        beginRound.classList.add("beginRound");
        beginRound.classList.add("pointer");
        beginRound.setAttribute("name", "beginRound");
        for (let i = 1; i <= 50; i++) {
            let option = document.createElement("option");
            option.setAttribute("value", i);
            option.classList.add("pointer");
            option.innerHTML = i;
            if (currentRound == i) {
                option.setAttribute("selected", "true");
            }

            if (currentRound == i && holding == 0) {
                option.setAttribute("selected", "true");
            } else {
                if (currentRound == i && causerPosition <= affecteePosition) {
                    option.setAttribute("selected", "true");
                }
            }

            beginRound.appendChild(option);
        }

        bottomMiddleDiv.appendChild(h4);
        bottomMiddleDiv.appendChild(beginRound);

        let h5 = document.createElement("h3");
        h5.innerHTML = "Ending Round";
        let endRound = document.createElement("select");
        endRound.classList.add("endRound");
        endRound.classList.add("pointer");
        endRound.setAttribute("name", "endRound");

        // determine whose init is higher, causer or affectee

        for (let i = 1; i <= 20; i++) {
            let option = document.createElement("option");
            option.setAttribute("value", i);
            option.classList.add("pointer");
            option.innerHTML = i;
            if (currentRound == i - 10 && holdingOneRound == 0) {
                option.setAttribute("selected", "true");
            } else {
                if (currentRound == i && causerPosition < affecteePosition) {
                    option.setAttribute("selected", "true");
                } else if (
                    currentRound == i - 1 &&
                    causerPosition >= affecteePosition
                ) {
                    option.setAttribute("selected", "true");
                }
            }
            endRound.appendChild(option);
        }

        bottomMiddleDiv.appendChild(h5);
        bottomMiddleDiv.appendChild(endRound);

        let bottomRightDiv = document.createElement("div");
        let h8 = document.createElement("h3");
        h8.innerHTML = "Submit";

        bottomRightDiv.appendChild(h8);
        bottomRightDiv.appendChild(submit);

        container.appendChild(bottomMiddleDiv);
        container.appendChild(bottomRightDiv);
        container.appendChild(buttonContainer);
        // container.appendChild(submit);

        modal.innerHTML = container.outerHTML;
        modalIsOpen = true;
    }

    async function submitCondition(nextAID) {
        let html = document.querySelector(".selected");
        let currentRound = html.getAttribute("data-round");
        let pID = html.getAttribute("data-participant");
        let dataNav = html.getAttribute("data-nav");
        let causerHTML = document.getElementsByName("causers");
        let affecteesHTML = document.getElementsByName("affectees");
        let conditionEndsHTML = document.getElementsByName("condition_ends");
        let conditionDescription =
            document.querySelector(".conditionsText").value;
        conditionDescription = conditionDescription
            .replace("'", "&apos;")
            .replace("#", "&num;")
            .replace("/", "&sol;");
        let startRoundHTML = document.querySelector(".beginRound");
        let endRoundHTML = document.querySelector(".endRound");
        let concentrationHTML = document.getElementsByName("concentration");
        let holdingHTML = document.getElementsByName("holding");

        let causerPID;
        causerPID = Array.from(causerHTML).find((causer) => {
            return causer.checked == true;
        }).id;
        let concentration;
        concentration = Array.from(concentrationHTML).find(
            (concentrationValue) => {
                return concentrationValue.checked == true;
            }
        ).value;

        let holding;
        holding = Array.from(holdingHTML).find(
            (holdingValue) => {
                return holdingValue.checked == true;
            }
        ).value;

        let affecteesHTMLArray = [];
        affecteesHTMLArray = Array.from(affecteesHTML).filter((affected) => {
            return affected.checked == true;
        });
        let affecteesPID = [];
        affecteesHTMLArray.forEach((affectee) => {
            affecteesPID.push(affectee.getAttribute("id").substring(1));
        });
        let affecteesString = affecteesPID.join(", ");
        let end_pID = Array.from(conditionEndsHTML).find((participant) => {
            return participant.checked == true;
        }).id;
        end_pID = end_pID.substring(1);

        let conditionEndsPID = Array.from(conditionEndsHTML)
            .find(item => item.checked)
            .id.slice(1);
        let startRound = Array.from(startRoundHTML).find(item => item.selected).value;
        let endRound = Array.from(endRoundHTML).find(item => item.selected).value;

        // get next cpID
        let latestConditionID = await dbQuery("GET", "getNextcpID/");
        let newCpID = parseInt(latestConditionID[0]?.cpID || 0) + 1;

        // send info to tbl_condition_pool
        let dataPool = `newConditionPoolItem/${conditionDescription.substring(
            0,
            15
        )}/${conditionDescription}`;
        await dbQuery("GET", dataPool);

        // determine next available taID in ct_tbl_condition_affectee
        let getNextTAID = await dbQuery("GET", "getNextTAID");
        let taID = getNextTAID.taID + 1;

        // send condition affectee info
        let dataConditionsAffectees = `addConditionAffectees/${taID}/${startRound}/${endRound}/${affecteesString}/${end_pID}`;

        await dbQuery("GET", dataConditionsAffectees);

        // send condition info
        let dataConditions = `addCondition/${ctApp[0].eID}/${causerPID}/${taID}/${conditionEndsPID}/${newCpID}/${concentration}/${holding}/${nextAID}`;
        await dbQuery("GET", dataConditions);

        load_encounter(ctAppEnc, dataNav);
        let modal = document.querySelector(".modal");
        modal.style.display = "none";
    }

    async function modalInit() {
        const modal = document.querySelector("#modal-body");
        const dropdown = document.querySelector(".initDropdown");
        const selectedOptionValue = dropdown.options[dropdown.selectedIndex].value;

        const container = document.createElement("div");
        container.classList.add("modal-body");
        let div = document.createElement("div");
        div.classList.add("modal-content");
        let h1 = document.createElement("h1");
        h1.classList.add("center");
        h1.innerText = "INITIATIVE";
        div.appendChild(h1);

        if (selectedOptionValue == "Party") {
            // get the character_names and their pID
            let partyParticipants = ctApp.filter((participant) => {
                return participant.pc == 1
            })

            // write the HTML that fits

            const h2 = document.createElement("h2");
            h2.classList.add("center");
            h2.innerText = "Our Heroes!"
            div.appendChild(h2);
            const div4 = document.createElement("div");
            div4.classList.add("center-div-align-left");

            partyParticipants.forEach((participant, index) => {
                const div2 = document.createElement("div");
                div2.classList.add("line");
                const input = document.createElement("input");
                input.classList.add("initValues")
                input.setAttribute("type", "text");
                input.setAttribute("maxLength", "2");
                input.setAttribute("data-init-pid", participant.pID);

                const input2 = document.createElement("input");
                input2.classList.add("secondaryInitValues")
                input2.classList.add("secondary-init-off")
                input2.setAttribute("type", "text");
                input2.setAttribute("maxLength", "2");
                input2.setAttribute("data-init-pid-secondary", participant.pID);

                const span = document.createElement("span");
                span.innerText = participant.character_name;
                div2.appendChild(input);
                div2.appendChild(input2);
                div2.appendChild(span);
                div4.appendChild(div2);
            })
            div.appendChild(div4)
            container.appendChild(div);

            const br = document.createElement("br");
            container.appendChild(br);
            const br2 = document.createElement("br");

            const button = document.createElement("button");
            button.setAttribute("onclick", "submitInitModal(1)")
            button.innerText = "SUBMIT";
            button.classList.add("center")

            const button2 = document.createElement("button");
            button2.setAttribute("onclick", "closeModal()")
            button2.innerText = "CLOSE";
            button2.classList.add("close-modal")
            button2.classList.add("center");

            let div3 = document.createElement("div");
            div3.classList.add("center")

            div3.appendChild(button)
            div3.appendChild(button2)
            container.appendChild(div3);
            container.appendChild(br2);

            modal.innerHTML = container.outerHTML;
            setTimeout(() => {
                let cursorField = document.querySelector('input[data-init-pid]')
                cursorField.focus();
            }, 90)

            modal.addEventListener("input", function (e) {
                // Get all left input elements
                const leftInputs = document.querySelectorAll('[data-init-pid]');

                // Create a Set to store encountered values
                const encounteredValues = new Set();
                const duplicatedNumbers = new Set();

                // Iterate through each left input element
                leftInputs.forEach(leftInput => {
                    // Get the value of the left input
                    const leftInputValue = leftInput.value.trim();

                    // Check if the value is not empty
                    if (leftInputValue !== '') {
                        // Check if the value has been encountered before
                        if (encounteredValues.has(leftInputValue)) {
                            // If yes, add it to the Set of duplicated numbers
                            duplicatedNumbers.add(leftInputValue);
                        } else {
                            // If not, add it to the Set of encountered values
                            encounteredValues.add(leftInputValue);
                        }
                    }
                });

                // Log the array of duplicated numbers to the console
                console.log('Duplicated Numbers:', Array.from(duplicatedNumbers));

                // Iterate through each left input element
                leftInputs.forEach(leftInput => {
                    // Get the value of the left input
                    const leftInputValue = leftInput.value.trim();

                    // Check if the value is in the duplicatedNumbers array
                    if (duplicatedNumbers.has(leftInputValue)) {
                        // Get the value of data-init-pid for the matching left input
                        const dataInitPidValue = leftInput.getAttribute('data-init-pid');

                        // Select all elements with data-init-pid-secondary matching the value
                        const secondaryInitOffElements = document.querySelectorAll(`[data-init-pid-secondary="${dataInitPidValue}"]`);

                        // Remove the secondary-init-off class from matching elements
                        secondaryInitOffElements.forEach(element => {
                            element.classList.remove('secondary-init-off');
                        });
                    }
                });

                // Iterate through each left input element
                leftInputs.forEach(leftInput => {
                    // Get the value of the left input
                    const leftInputValue = leftInput.value.trim();

                    // Check if the value is NOT in the duplicatedNumbers array
                    if (!duplicatedNumbers.has(leftInputValue)) {
                        // Get the value of data-init-pid for the matching left input
                        const dataInitPidValue = leftInput.getAttribute('data-init-pid');

                        // Select all elements with data-init-pid-secondary matching the value
                        const secondaryInitOffElements = document.querySelectorAll(`[data-init-pid-secondary="${dataInitPidValue}"]`);

                        // Add the secondary-init-off class to matching elements
                        secondaryInitOffElements.forEach(element => {
                            element.classList.add('secondary-init-off');
                        });
                    }
                });
            });

        } else {
            // determine which participants in ctApp have character_name that matches selectedOptionValue
            const creatureParticipants = ctApp.filter((participant) => {
                return participant.character_name == selectedOptionValue
            })
            // get their init_modifiers
            const initModifier = creatureParticipants[0].init_modifier

            // write the HTML that fits
            const h2 = document.createElement("h2");
            h2.classList.add("center");
            h2.innerText = (
                creatureParticipants.length > 1
                    ? creatureParticipants.length
                    : ""
            )
                + " "
                + creatureParticipants[0].character_name + "(s)"
            div.appendChild(h2);

            const divOpponents = document.createElement("div");
            divOpponents.classList.add("center-div-align-left");

            creatureParticipants.forEach((creature, index) => {
                let div2 = document.createElement("div");
                div2.classList.add("line")
                let input = document.createElement("input");
                input.setAttribute("type", "text");
                input.setAttribute("data-init-modifier", creature.init_modifier || 0);
                // input.setAttribute("value", creature.pID);
                input.setAttribute("maxLength", "2");
                let span = document.createElement("span");
                span.innerText = (creature.init_modifier >= 0 ? " + " : " - ") + Math.abs(creature.init_modifier) + " = ";
                let strong = document.createElement("strong");
                strong.setAttribute("data-init-pid", creature.pID);
                strong.innerText = "0";

                div2.appendChild(input);
                div2.appendChild(span);
                div2.appendChild(strong);
                divOpponents.appendChild(div2);
            })
            div.appendChild(divOpponents);
            container.appendChild(div);

            let br = document.createElement("br");
            container.appendChild(br);
            let br2 = document.createElement("br");

            let button = document.createElement("button");
            button.setAttribute("onclick", "submitInitModal(0)")
            button.innerText = "SUBMIT";
            button.classList.add("center")

            let button2 = document.createElement("button");
            button2.setAttribute("onclick", "closeModal()")
            button2.classList.add("close-modal")
            button2.innerText = "CLOSE";
            button2.classList.add("center");

            let div3 = document.createElement("div");
            div3.classList.add("center")

            div3.appendChild(button)
            div3.appendChild(button2)
            container.appendChild(div3);
            container.appendChild(br2);

            modal.innerHTML = container.outerHTML;

            modal.innerHTML = container.outerHTML;
            setTimeout(() => {
                let cursorField = document.querySelector('input[data-init-modifier]')
                cursorField.focus();
            }, 90)

            modal.addEventListener("input", function (e) {

                const inputElement = e.target;
                const parentDiv = inputElement.parentElement;
                let strongElement = parentDiv.querySelector('strong');
                const inputValue = inputElement.value.trim(); // Trim leading/trailing white spaces
                if (inputValue === "") {
                    strongElement.innerText = "0";
                } else {
                    let parsedValue = parseInt(inputValue, 10);
                    let initModifier = parseInt(inputElement.getAttribute('data-init-modifier'), 10);
                    let newValue = parsedValue + initModifier;
                    strongElement.innerText = newValue;
                }
                const allInputs = e.target.parentElement;
            });
        }
        const cm = document.querySelector(".modal-content");
        function showContextMenu(show = true) {
            cm.style.display = show ? "block" : "none";
        }

    }

    async function submitInitModal(PC) {

        if (PC == 0) {
            // Assuming you have a NodeList, for example:
            let nodeList = document.querySelectorAll('input[type="text"] + span + strong');

            let strongValuesArray = Array.from(nodeList).map(function (element) {
                return element.innerText;
            });
            // Now strongValuesArray contains the innerText values of the <strong> elements

            const initialOrderPids = Array.from(nodeList).map(function (element) {
                return element.getAttribute('data-init-pid')
            })

            // sort strongValuesArray in descending order
            let sortedValues = strongValuesArray.slice().sort((a, b) => b - a);
            let indexMapping = strongValuesArray.map((_, index) => index)
                .sort((a, b) => strongValuesArray[b] - strongValuesArray[a]);

            const newOrderPids = indexMapping.map(index => initialOrderPids[index]);
            const reorderedNumericValues = Array.from({ length: sortedValues.length }, (_, index) => index + 1);

            let stringToSend = ""
            initialOrderPids.forEach((creature, index) => {
                stringToSend += (index > 0 ? " | " : "") + newOrderPids[index] + ", " + reorderedNumericValues[index] + ", " + sortedValues[index]
            })

            let postData = initialOrderPids.map((creature, index) => ({
                pID: newOrderPids[index],
                numeric_value: "", // Set this to the appropriate value or an empty string
                init: sortedValues[index],
            }));

            await dbQueryPost("orderInitiative", postData)
                .then((data) => {
                    console.log(data); // Handle the response from the server
                })
                .catch((error) => {
                    // Handle errors here
                });

            // where pID = newOrderPids[x], set numeric_value = reorderedNumericValues[x] and init = sortedValues[x]
        } else { // if PC == 1
            let nodeList = document.querySelectorAll('.initValues');
            let secondaryNodeList = document.querySelectorAll(".secondaryInitValues:not(.secondary-init-off)");

            let strongValuesArray = Array.from(nodeList).map(function (element) {
                return element.value;
            });

            // Now strongValuesArray contains the input values
            const initialOrderPids = Array.from(nodeList).map(function (element) {
                return element.getAttribute('data-init-pid');
            });

            // sort strongValuesArray in descending order
            let sortedValues = strongValuesArray.slice().sort((a, b) => b - a);
            let indexMapping = strongValuesArray.map((_, index) => index)
                .sort((a, b) => strongValuesArray[b] - strongValuesArray[a]);

            const newOrderPids = indexMapping.map(index => initialOrderPids[index]);

            // Create a mapping of data-init-pid to secondary_init values
            const secondaryInitValuesMap = {};
            secondaryNodeList.forEach(element => {
                const secondaryInitValue = element.value;
                const secondaryInitPid = element.getAttribute('data-init-pid-secondary');
                secondaryInitValuesMap[secondaryInitPid] = secondaryInitValue;
            });

            let stringToSend = "";
            const postData = initialOrderPids.map((creature, index) => {
                const secondaryInitValue = secondaryInitValuesMap[newOrderPids[index]];
                stringToSend += (index > 0 ? " | " : "") + newOrderPids[index] + ", " + "0" + ", " + sortedValues[index];

                return {
                    pID: newOrderPids[index],
                    numeric_value: "", // Set this to the appropriate value or an empty string
                    init: sortedValues[index],
                    secondary_init: secondaryInitValue, // Add secondary_init to the postData object
                };
            });

            await dbQueryPost("orderInitiative", postData)
                .then((data) => {
                    console.log(data); // Handle the response from the server
                })
                .catch((error) => {
                    // Handle errors here
                });


        }

        let html = document.querySelector(".selected");
        let dataNav = html.getAttribute("data-nav");
        load_encounter(ctAppEnc, dataNav);
    }

    async function dbQuery(httpReqType, httpReqString) {
        // arguments should look something like "GET" and "getSomethingFromBackEnd/42/true"
        let dbReturn = makePromise(httpReqType, httpReqString);
        let dbReturnJSON = await dbReturn;
        let unpackdbReturn = JSON.parse(dbReturnJSON);
        return unpackdbReturn;

        function makePromise(httpReqType, httpReqString) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                xhr.open(httpReqType, `../${httpReqString}`, true);
                xhr.onload = () => resolve(xhr.responseText);
                xhr.onerror = () => resolve("Request Failed");
                xhr.send();
            });
        }
    }

    async function dbQueryPost(httpReqString, requestData) {
        try {
            const response = await fetch(`../${httpReqString}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData),
            });

            if (response.ok) {
                const responseData = await response.json();
                return responseData;
            } else {
                throw new Error('Request Failed');
            }
        } catch (error) {
            console.error('Error:', error);
            throw error; // Rethrow the error for handling in the caller
        }
    }


    function findLargestSubarray(arr) {
        let largestSubarray = arr[0];
        let largestLength = arr[0]?.length;
        for (let i = 1; i < arr?.length; i++) {
            if (arr[i].length > largestLength) {
                largestSubarray = arr[i];
                largestLength = arr[i].length;
            }
        }
        return largestLength;
    }

    function buildASection(
        actionType,
        ctRound,
        numberActions,
        ctApp
    ) {
        let round = ctRound;
        for (let j = 1; j <= numberActions; j++) {
            let section2 = document.createElement("div");

            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-" + actionType, j);

            let div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add(actionType + (actionType == "attack" && j % 2 == 0 ? "_alt" : ""));
            div5.classList.add("center");
            div5.textContent =
                actionType.charAt(0).toUpperCase() +
                actionType.substring(1) +
                (numberActions > 1 ? " #" + j : "");
            let div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add(actionType + (actionType == "attack" && j % 2 == 0 ? "_alt" : ""));
            div6.classList.add("center");
            div6.textContent = "Hit?";
            let div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add(actionType + (actionType == "attack" && j % 2 == 0 ? "_alt" : ""));
            div7.classList.add("center");
            div7.textContent = "Target(s)";
            let div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add(actionType + (actionType == "attack" && j % 2 == 0 ? "_alt" : ""));
            div8.classList.add("center");
            div8.textContent = "hp";
            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);
            ctApp.forEach((participant) => {
                let div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add(actionType + (actionType == "attack" && j % 2 == 0 ? "_alt" : ""));
                div9.classList.add("center");
                div9.setAttribute("data-participant", participant.pID);
                let div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add(actionType + (actionType === "attack" && j % 2 === 0 ? "_alt" : ""));
                div10.classList.add("center");
                let div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add(actionType + (actionType === "attack" && j % 2 === 0 ? "_alt" : ""));
                div11.classList.add("center");
                let div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add(actionType + (actionType === "attack" && j % 2 === 0 ? "_alt" : ""));
                div12.classList.add("center");
                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
                round.appendChild(section2);
            });
        }
        return round;
    }

    async function fillEncounterDropdown() {

        const encounterList = await dbQuery("GET", "availableEncounters")
        let select = document.querySelector(".encounterDropdown");
        select.innerHTML = "";

        encounterList.forEach((enc) => {
            const option = document.createElement("option");
            option.setAttribute("value", enc.eID);
            option.innerText = `(${enc.eID}) ${enc.campaign} - ${enc.location} - ${enc.description}`;
            option.removeAttribute("selected");
            if (enc.eID == ctAppEnc) {
                option.setAttribute("selected", "selected")
            }
            // else {
            //     option.removeAttribute("selected")
            // }
            select.appendChild(option);
        })
    }

    async function fillInitDropdown() {
        // get an array of unique participant names where pc = 0
        let names = [];
        ctApp.forEach((participant) => {
            if (participant.pc === 0) {
                names.push(participant.character_name)
            }
        })
        let uniqueCombatantNames = [...new Set(names)]


        let select = document.querySelector(".initDropdown");
        select.innerHTML = "";
        // let container = document.createElement("div");
        let option = document.createElement("option");
        option.setAttribute("value", "Party");
        option.setAttribute("selected", "selected");
        option.innerText = "Party"
        select.appendChild(option);

        uniqueCombatantNames.forEach((combatant, index) => {
            let option2 = document.createElement("option")
            option2.setAttribute("value", combatant);
            option2.innerText = combatant;
            select.appendChild(option2);
        });
        // div.appendChild(select);
        // select.appendChild(div);

    }

    function init_modal() {
        let initDropdown = document.querySelector(".initDropdown")
        let selectedOptionText;
        for (let i = 0; i < initDropdown.options.length; i++) {
            if (initDropdown.options[i].selected) {
                selectedOptionText = initDropdown.options[i].text;
                break; // Exit the loop when the selected option is found
            }
        }
        modalInit()
        pushModal()
        modalIsOpen = true;
    }

    function resizeSections() {
        let variety = [
            "section='1'",
            "attack",
            "bonus",
            "react",
            "section='2'",
        ];
        variety.forEach((item) => {
            let grab = document.querySelectorAll(`[data-round] [data-${item}]`);
            let maxWidth = 0;
            grab.forEach((round) => {
                maxWidth =
                    maxWidth > round.clientWidth ? maxWidth : round.clientWidth;
            });
            grab.forEach((round) => {
                round.style.width = maxWidth + "px";
            });
        });
    }

    function navify() {
        document.addEventListener("keydown", keydownEventListener);
        document.addEventListener("click", clickEventListener);

        document.addEventListener("click", async function (event) {
            if (event.target.getAttribute("data-nav")) {
                let myElement = document.querySelectorAll(".selected");
                let nav = myElement[0].getAttribute("data-nav");
                let targetNum = Number(nav) + 1;
                let newTarget;
                if (nav < cellCountVertical - 1) {
                    myElement.forEach((ele) => {
                        ele.classList.remove("selected");
                    });
                    newTarget = document.querySelector(
                        '[data-nav="' + targetNum + '"]'
                    );
                    event.target.classList.add("selected");
                    event.target.nextSibling.classList.add("selected");
                    event.target.nextSibling.nextSibling.classList.add(
                        "selected"
                    );
                    event.target.nextSibling.nextSibling.nextSibling.classList.add(
                        "selected"
                    );
                }
                // }
            }
        });

        // Get a reference to the initiative dropdown element
        let dropdown = document.querySelector(".initDropdown");
        // Add an event listener to the initiative dropdown to detect changes
        dropdown.addEventListener("change", function () {
            // Loop through the options to find the selected one
            let options = dropdown.options;
            for (let i = 0; i < options.length; i++) {
                if (options[i].selected) {
                    // Remove the selected attribute from all options
                    for (let j = 0; j < options.length; j++) {
                        options[j].removeAttribute("selected");
                    }
                    // Add the selected attribute to the currently selected option
                    options[i].setAttribute("selected", "selected");
                    break; // Exit the loop when the selected option is found
                }
            }
        });


    }

    // function new_encounter(encounterID) {
    //     "hello??????"
    //     let modalContainer = document.createElement("div");
    //     modalContainer.innerHTML;

    //     let innerContainer = document.createElement("div");
    //     innerContainer.classList.add("modalContainer");

    //     let participantsHeader = document.createElement("h2");
    //     participantsHeader.innerText = "Participants";

    //     let x = document.getElementById("modal-body");
    //     x.innerHTML = modalContainer.outerHTML;
    //     launchActionModal();
    // }

    function launchActionModal(event) {
        modalActions();
        pushModal()
    }

    function closeModalBox(closeModal) {

        closeModal.addEventListener("click", function (e) {
            modal.style.display = "none";
        });

        window.addEventListener("click", function (e) {
            if (e.target == modal) {
                modal.style.display = "none";
                modalIsOpen = false;
            }
        });
        modalIsOpen = false
    }


    const keydownEventListener = async function (event) {
        const modal = document.querySelector(".modal");
        if (!modalIsOpen) {
            blurAllElements();
        }
        if (event.key === "Tab" && !modalIsOpen) {
            event.preventDefault();
        }

        if (event.key === "ArrowUp" || event.shiftKey && event.key === "Tab") {
            if (modal?.style?.display == "none" || modal.style.display == "") {
                let myElement = document.querySelectorAll(".selected");
                let nav = myElement[0].getAttribute("data-nav");
                let targetNum = Number(nav) - 1;
                let newTarget;
                if (nav != 1) {
                    myElement.forEach((ele) => {
                        ele.classList.remove("selected");
                    });
                    newTarget = document.querySelector(
                        '[data-nav="' + targetNum + '"]'
                    );
                    newTarget.classList.add("selected");
                    newTarget.nextSibling.classList.add("selected");
                    newTarget.nextSibling.nextSibling.classList.add("selected");
                    newTarget.nextSibling.nextSibling.nextSibling.classList.add(
                        "selected"
                    );
                    if (newTarget.classList.contains("selected")) {
                        if (
                            newTarget.parentElement.parentElement.classList.contains(
                                "sometimes_hidden"
                            ) &&
                            newTarget.classList.contains("selected")
                        ) {
                            let p = document.querySelectorAll(".sometimes_hidden");
                            p.forEach((element) => {
                                element.classList.remove("hidden");
                            });
                        } else {
                            let p = document.querySelectorAll(".sometimes_hidden");
                            p.forEach((element) => {
                                element.classList.add("hidden");
                            });
                        }
                    }
                    newTarget.scrollIntoViewIfNeeded(true);
                }
            }
        } else if (event.key === "ArrowDown" || event.key === "Tab") {
            if (modal?.style?.display == "none" || modal.style.display == "") {
                let myElement = document.querySelectorAll(".selected");
                let nav = myElement[0].getAttribute("data-nav");
                let targetNum = Number(nav) + 1;
                let newTarget;
                if (nav < cellCountVertical - 1) {
                    myElement.forEach((ele) => {
                        ele.classList.remove("selected");
                    });
                    newTarget = document.querySelector(
                        '[data-nav="' + targetNum + '"]'
                    );
                    newTarget.classList.add("selected");
                    newTarget.nextSibling.classList.add("selected");
                    newTarget.nextSibling.nextSibling.classList.add("selected");
                    newTarget.nextSibling.nextSibling.nextSibling.classList.add(
                        "selected"
                    );
                    if (newTarget.classList.contains("selected")) {
                        if (
                            newTarget.parentElement.parentElement.classList.contains(
                                "sometimes_hidden"
                            ) &&
                            newTarget.classList.contains("selected")
                        ) {
                            let p = document.querySelectorAll(".sometimes_hidden");
                            p.forEach((element) => {
                                element.classList.remove("hidden");
                            });
                        } else {
                            let p = document.querySelectorAll(".sometimes_hidden");
                            p.forEach((element) => {
                                element.classList.add("hidden");
                            });
                        }
                    }
                    newTarget.scrollIntoViewIfNeeded(true);
                }
            }
        }
        else if (event.altKey && event.keyCode == 81) {
            launchConditionsModal("turn");
        } else if (event.altKey && event.keyCode == 67) {
            alert("HUZZAH!");
        }
    };

    function launchConditionsModal(
        affected,
        concentration,
        conditionName,
        holding,
        holdingOneRound,
        nextAID
    ) {
        if (affected == "turn") {
            concentration = 0;
        }
        modalConditions(
            affected,
            concentration,
            conditionName,
            holding,
            holdingOneRound,
            nextAID
        );
        pushModal()
    }

    function launchInitModal(selectedOptionText) {
        pushModal()
        modalIsOpen = true;
    }

    function pushModal() {
        let modal = document.querySelector(".modal");
        let closeModalButtons = document.querySelectorAll(".close-modal");
        modal.style.display = "block";

        // Add the event listener or perform actions for each close button
        closeModalButtons.forEach((closeModal) => {
            closeModalBox(closeModal);
        });
    }
    function closeModal() {
        let modal = document.querySelector(".modal");
        let closeModalButtons = document.querySelectorAll(".close-modal");
        modal.style.display = "none";
        modalIsOpen = false;
    }

    const clickEventListener = async function (event) {
        if (event.target.getAttribute("data-nav")) {
            let myElement = document.querySelectorAll(".selected");
            let nav = myElement[0].getAttribute("data-nav");
            let targetNum = Number(nav) + 1;
            let newTarget;
            if (nav < cellCountVertical - 1) {
                myElement.forEach((ele) => {
                    ele.classList.remove("selected");
                });
                newTarget = document.querySelector(
                    '[data-nav="' + targetNum + '"]'
                );
                event.target.classList.add("selected");
                event.target.nextSibling.classList.add("selected");
                event.target.nextSibling.nextSibling.classList.add("selected");
                event.target.nextSibling.nextSibling.nextSibling.classList.add(
                    "selected"
                );
            }
            // }
        }
    };

    async function deleteNote(dataAidValue) {
        const data = {
            aID: dataAidValue
        }
        await dbQueryPost("deleteNote", data)
            .then((data) => {
                console.log(data); // Handle the response from the server
            })
            .catch((error) => {
                // Handle errors here
            });
        // let html = document.querySelector(".selected");
        // let dataNav = html.getAttribute("data-nav");
        // load_encounter(ctAppEnc, dataNav);
        refresh_encounter();

    }

    async function deleteParticipant(pID) {
        const data = {
            pID: pID,
            eID: ctAppEnc
        }

        await dbQueryPost("deleteParticipant", data)
            .then((data) => {
                console.log(data); // Handle the response from the server
            })
            .catch((error) => {
                // Handle errors here
            });

        // clean up ct_tbl_participants:
        // where eID and character_name are (as a set) NOT duplicated, set numeric_value to "" 



        refresh_encounter();
    }

    async function deleteAction(dataAidValue) {

        const data = {
            aID: dataAidValue
        }

        const deleteEm = await dbQuery("GET", "getDeleteActionData/" + dataAidValue)
        deleteEm.forEach((obj) => {
            obj.aID = dataAidValue
        })
        const deleteData = {
            aID: dataAidValue,
            targetID: deleteEm[0].targetID,
            taID: deleteEm[0].taID,
            conditionID: deleteEm[0].conditionID
        }
        await dbQueryPost("deleteAction", deleteData)
            .then((data) => {
                console.log(data); // Handle the response from the server
            })
            .catch((error) => {
                // Handle errors here
            });

        let updateData = {};
        let uniqueObjectsSet = new Set();

        deleteEm.forEach((obj, index) => {
            const object = {
                tID: obj.tID,
                damage: obj.damage,
                target_pID: obj.target_pID
            };

            // Create a string representation of the object for easy comparison
            const objectString = JSON.stringify(object);

            // Check if the object is unique before adding it to updateData
            if (!uniqueObjectsSet.has(objectString)) {
                uniqueObjectsSet.add(objectString);
                updateData[index] = { object };
            }
        });

        await dbQueryPost("deleteActionUpdateTargetHPs", updateData)
            .then((data) => {
                console.log(data); // Handle the response from the server
            })
            .catch((error) => {
                // Handle errors here
            });
        let html = document.querySelector(".selected");
        let dataNav = html.getAttribute("data-nav");
        load_encounter(ctAppEnc, dataNav);
    }

    function add_participants_modal() {
        modalParticipants()
        pushModal()
    }

    async function modalParticipants() {
        const modal = document.querySelector("#modal-body");
        modal.innerHTML = "";
        const container = document.createElement("div");
        container.classList.add("modal-body");
        const div = document.createElement("div");
        div.classList.add("modal-content");

        const h1 = document.createElement("h1");
        h1.classList.add("center");
        h1.innerText = "ADD PARTICIPANTS";
        div.appendChild(h1);
        container.appendChild(div);

        const container2 = document.createElement("div");
        container2.classList.add("participant-container");

        // left container
        const leftContainer = document.createElement("div");
        leftContainer.classList.add("left-container");
        const h3 = document.createElement("h3");
        h3.innerText = "Character List";

        leftContainer.appendChild(h3);

        // get a list of the characters who are available, i.e. pc = 1
        const availablePCs = await dbQuery("GET", "getCharacters?isPC=1");

        const toggle = document.createElement("div");
        toggle.classList.add("list-item");

        const oppInput = document.createElement("input");
        oppInput.setAttribute("type", "checkbox");
        oppInput.setAttribute("id", "toggleSelect")
        oppInput.classList.add("toggle-participants");
        const oppInputLabel = document.createElement("label");
        oppInputLabel.setAttribute("for", "toggleSelect")
        oppInputLabel.innerText = "SELECT/UNSELECT ALL (toggle) ";

        toggle.appendChild(oppInput);
        toggle.appendChild(oppInputLabel);

        leftContainer.appendChild(toggle);

        let div2;
        // for each list item
        availablePCs.forEach((pc, index) => {
            div2 = document.createElement("div");
            div2.classList.add("list-item");
            const hpLabel = document.createElement("span");
            hpLabel.classList.add("hideHP")
            hpLabel.innerText = "HP: ";
            const hp = document.createElement("input");
            hp.setAttribute("type", "text");
            hp.classList.add("hideHP")
            hp.value = pc.max_hp
            hp.classList.add("hp-input");
            const input = document.createElement("input");
            input.setAttribute("type", "checkbox");
            input.setAttribute("id", "char" + index);
            input.setAttribute("data-chid", pc.chID);
            input.setAttribute("data-ac", pc.ac);
            input.classList.add("character-checkbox");
            input.setAttribute("data-name", pc.character_name)
            const label = document.createElement("label");
            label.setAttribute("for", "char" + index);
            label.innerText = pc.character_name;
            div2.appendChild(hpLabel);
            div2.appendChild(hp);
            div2.appendChild(input);
            div2.appendChild(label);
            leftContainer.appendChild(div2);
        })

        /////////////////////////////////

        // right container
        const rightContainer = document.createElement("div");
        rightContainer.classList.add("right-container");
        const h32 = document.createElement("h3");
        h32.innerText = "Opponent List";

        rightContainer.appendChild(h32);

        const monsterContainer = document.createElement("div");
        monsterContainer.style.height = "35px";
        monsterContainer.classList.add("monster-input-container")

        const select = document.createElement("select");
        select.setAttribute("id", "monsterSelect");

        const opponents = await dbQuery("GET", "getCharacters?isPC=0")

        const option = document.createElement("option");
        option.setAttribute("value", "monster0");
        option.setAttribute("data-hp", "0");
        option.setAttribute("data-chid", "0");
        option.setAttribute("data-ac", "0")
        option.innerText = "None";
        select.appendChild(option);

        // for each opponent...
        opponents.forEach((opponent, index) => {
            const option = document.createElement("option");
            option.setAttribute("value", "monster" + opponent.chID);
            option.setAttribute("data-hp", opponent.max_hp);
            option.setAttribute("data-chid", opponent.chID);
            option.setAttribute("data-ac", opponent.ac)
            option.innerText = opponent.character_name;
            select.appendChild(option);
        })


        /////////////////////////////

        monsterContainer.appendChild(select);

        const detailsContainer = document.createElement("div");
        const detailsInput = document.createElement("input");
        detailsInput.setAttribute("id", "detailsInput")
        const detailsInputLabel = document.createElement("label");
        detailsInputLabel.setAttribute("for", "detailsInput");
        detailsInputLabel.innerText = "New Name: "
        detailsContainer.appendChild(detailsInputLabel);
        detailsContainer.appendChild(detailsInput);



        const detailsContainer2 = document.createElement("div");
        detailsContainer2.classList.add("details-container")
        const hpInput = document.createElement("input");
        hpInput.setAttribute("id", "hpInputOpp")
        hpInput.classList.add("hp-input")
        hpInput.value = "";
        const hpInputLabel = document.createElement("label");
        hpInputLabel.setAttribute("for", "hpInputOpp");
        hpInputLabel.innerText = "HP: "

        const numOpponents = document.createElement("select");
        numOpponents.setAttribute("id", "numOpp")
        const numOpponentsLabel = document.createElement("label");
        numOpponentsLabel.setAttribute("for", "numOpp");
        numOpponentsLabel.innerText = "# of Opponents: "

        for (let i = 1; i <= 30; i++) {
            const option = document.createElement("option");
            option.setAttribute("value", i);
            option.innerText = i;
            numOpponents.appendChild(option);
        }

        detailsContainer2.appendChild(hpInputLabel);
        detailsContainer2.appendChild(hpInput);
        detailsContainer2.appendChild(numOpponentsLabel);
        detailsContainer2.appendChild(numOpponents);


        const btnContainer = document.createElement("div");
        btnContainer.classList.add("update-close-container");
        const button1 = document.createElement("button");
        button1.setAttribute("onclick", "updateParticipantList()");
        button1.innerText = "ADD";
        const button2 = document.createElement("button");
        button2.setAttribute("onclick", "closeModal()");
        button2.innerText = "CLOSE";

        btnContainer.appendChild(button1);
        btnContainer.appendChild(button2);

        leftContainer.appendChild(div2);

        rightContainer.appendChild(h32);
        rightContainer.appendChild(monsterContainer);
        rightContainer.appendChild(detailsContainer);
        rightContainer.appendChild(detailsContainer2);
        rightContainer.appendChild(btnContainer);


        container2.appendChild(leftContainer)
        container2.appendChild(rightContainer)
        div.appendChild(container2);
        container.appendChild(div);
        modal.appendChild(container);
        const cm = document.querySelector(".modal-content");
        function showContextMenu(show = true) {
            cm.style.display = show ? "block" : "none";
        }

        const toggler = document.querySelector(".toggle-participants");
        const participants = document.querySelectorAll(".character-checkbox");

        toggler.addEventListener("change", () => {
            participants.forEach((participant) => {
                participant.checked = toggler.checked;
                toggleHideHP(participant);
            });
        });

        participants.forEach((participant) => {
            participant.addEventListener("change", () => {
                toggleHideHP(participant);
            });
        });

        function toggleHideHP(participant) {
            const hideHPInputs = [
                participant.previousElementSibling,
                participant.previousElementSibling.previousElementSibling
            ];

            hideHPInputs.forEach((input) => {
                input.classList.toggle("hideHP", !participant.checked);
            });
        }

        // const options = document.querySelectorAll('.monsterSelect option');
        // Select the elements
        const monsterSelect = document.getElementById('monsterSelect');
        const hpInputOpp = document.getElementById('hpInputOpp');

        // Add event listener to the monsterSelect
        monsterSelect.addEventListener('change', () => {
            // Get the selected option
            const selectedOption = monsterSelect.options[monsterSelect.selectedIndex];

            // Update the value of hpInputOpp with the data-hp attribute of the selected option
            hpInputOpp.value = selectedOption.dataset.hp || '';

            const resetNewName = document.getElementById("detailsInput");
            resetNewName.value = ""
        });
        modalIsOpen = true;


    }

    async function updateParticipantList() {
        // get characters
        // Select all elements with class "list-item" (excluding the first match) where the child checkbox is checked
        const selectedCharacters = document.querySelectorAll('.list-item:not(:first-child) input.character-checkbox:checked');

        let group = []
        // Do something with the selected elements
        selectedCharacters.forEach((item, index) => {
            const currentItem = {
                chID: item.getAttribute("data-chid"),
                character_name: item.getAttribute("data-name"),
                ac: item.getAttribute("data-ac"),
                eID: ctAppEnc,
                max_hp: item.previousElementSibling.value,
                numeric_value: ""
            }
            aaa = currentItem;
            group.push(currentItem);
        });

        const monsters = document.querySelector("#monsterSelect")
        const monsterSelected = monsters.options[monsters.selectedIndex];
        if (monsterSelected.textContent != "None") {
            const chID = monsterSelected.getAttribute("data-chid");
            const ac = monsterSelected.getAttribute("data-ac");

            let participantName = document.querySelector("#detailsInput").value;
            participantName = participantName == "" ? monsterSelected.textContent : participantName;
            let hp = document.querySelector("#hpInputOpp").value;
            let numOpponents = document.querySelector("#numOpp")
            let number = numOpponents.options[numOpponents.selectedIndex].value;

            // let highestNumericKey = Math.max(...Object.keys(group).map(Number), 0) + 1;

            for (let i = 0; i <= number - 1; i++) {
                const currentItem = {
                    chID: chID,
                    character_name: participantName,
                    eID: ctAppEnc,
                    ac: ac,
                    max_hp: hp,
                    numeric_value: number > 1 ? i + 1 : ""
                }
                bbb = currentItem
                group.push(currentItem);
            }
        }

        // we have a group array containing objects, where each object gets action in the db

        for (const obj of group) {
            const chidCheck = await dbQuery("GET", "chidCheck/" + obj.chID)
            let latestParticipant = await dbQuery("GET", "getLatestParticipant")
            obj.pID = parseInt(latestParticipant[0].pID) + 1
            await dbQueryPost("updateEncounterParticipants", obj)
            await dbQueryPost("addParticipant", obj)
        }

        // await dbQueryPost("addParticipants", group)
        refresh_encounter();
    }

    async function change_encounter() {
        // Get the select element
        const selectElement = document.querySelector(".encounterDropdown");

        // Get the selected option
        var selectedOption = selectElement.options[selectElement.selectedIndex];

        ctAppEnc = selectedOption.value;
        const data = {
            id: ctAppEnc
        }

        await dbQueryPost("saveEncounterID", data)
        refresh_encounter();
    }

    async function refresh_encounter() {


        const encounteredNames = {};
        const resultArray = [];

        // Filter the array based on conditions
        ctApp.forEach((character) => {
            // Check if character_name has a number in numeric_value
            const hasNumber = /\d/.test(character.numeric_value);

            // Check if character_name is not a duplicate and has a number in numeric_value
            if (!encounteredNames[character.character_name] && hasNumber) {
                resultArray.push(character);
                encounteredNames[character.character_name] = true;
            }
        });


        const newObj = {
            pID: resultArray[0]?.pID,
        }

        await dbQueryPost("removeDuplicateNumericValues", newObj)
            .then((data) => {
                console.log(data); // Handle the response from the server
            })
            .catch((error) => {
                // Handle errors here
            });


        let html = document?.querySelector(".selected");
        let dataNav = html?.getAttribute("data-nav") || 1;
        await load_encounter(ctAppEnc, dataNav);
        load_encounter(ctAppEnc, dataNav);
    }

    function blurAllElements() {
        // Get all focusable elements
        const focusableElements = document.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');

        // Blur each focusable element
        focusableElements.forEach(element => {
            element.blur();
        });
    }

    // Clicking on target's name toggles X in the text input
    const modalClickListener = function (event) {
        if (event.target.classList.contains("modal_text_inputs")) {
            if (event.target.previousSibling.value === "") {
                event.target.previousSibling.value = "x";
            } else if (event.target.previousSibling.value === "x") {
                event.target.previousSibling.value = "";
            }
        }
    };

    async function endCondition() {
        const htmlSelected = document.querySelector(".selected");
        const selectedID = htmlSelected.getAttribute("data-participant");
        const endThisCondition = document.querySelector("[data-cm-condition-id]");
        const conditionID = endThisCondition.getAttribute("data-cm-condition-id");
        let affecteeID = endThisCondition.getAttribute("data-cm-affected-id");
        const round = endThisCondition.getAttribute("data-cm-round");
        const taid = endThisCondition.getAttribute("data-cm-taid");
        const conditionState = endThisCondition.getAttribute(
            "data-cm-concentration-or-affected"
        );
        if (conditionState == "concentration") {
            affecteeID = htmlSelected.getAttribute("data-cm-causer-id");
        }

        await dbQuery(
            "GET",
            "endCondition/" +
            conditionID +
            "/" +
            affecteeID +
            "/" +
            round +
            "/" +
            conditionState +
            "/" +
            taid
        );
        refresh_encounter()
    }

    // determine if participants are duplicated - e.g. goblin #1 and goblin #2
    // and apply #x to their names in the combat tracker
    async function handleNumericValues() {
        // look for participants with duplicate names, e.g. goblin and goblin
        const characterNameCounts = ctApp.reduce((acc, obj) => {
            if (!acc[obj.character_name]) {
                acc[obj.character_name] = [obj];
            } else {
                acc[obj.character_name].push(obj);
            }
            return acc;
        }, {});

        const duplicatedCharacterNames = Object.keys(characterNameCounts).filter(
            (characterName) => characterNameCounts[characterName].length > 1
        );

        const orderedCharacterObjects = duplicatedCharacterNames.map(characterName => {
            const characterObjects = ctApp.filter(obj => obj.character_name === characterName);
            characterObjects.sort((a, b) => b.init - a.init); // Sort in descending order by "init"
            return characterObjects;
        });

        orderedCharacterObjects.forEach((collection) => {
            collection.sort((a, b) => b.init - a.init)
        });

        // change participants numeric values in db, by initiative positions;
        // goblin with init 20 would get a 1, while goblin with init 19
        // would get a 2, and so on.
        await orderedCharacterObjects.forEach(async (objects) => {
            await objects.forEach(async (obj, index) => {
                await dbQuery("GET", "arrangeParticipantsByInit/" + obj.pID + "/" + (index + 1))
            })
        })
    }

</script>