<script>
    async function dbQuery(httpReqType, httpReqString) {
        // arguments should look something like "GET" and "getSomethingFromBackEnd/42/true"
        let dbReturn = makePromise(httpReqType, httpReqString);
        let dbReturnJSON = await dbReturn;
        let unpackdbReturn = JSON.parse(dbReturnJSON);
        return unpackdbReturn;

        function makePromise(httpReqType, httpReqString) {
            httpReqString = httpReqString;
            let request = new Promise((resolve, reject) => {
                let xhr = new XMLHttpRequest();
                xhr.open(httpReqType, "../" + httpReqString, true);
                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const text = xhr.responseText;
                        resolve(text);
                    } else {
                        reject(xhr.statusText);
                    }
                };
                xhr.onerror = () => reject("Request Failed");
                xhr.send();
            });
            return request;
        }
    }

    function findLargestSubarray(arr) {
        let largestSubarray = arr[0];
        let largestLength = arr[0].length;
        for (let i = 1; i < arr.length; i++) {
            if (arr[i].length > largestLength) {
                largestSubarray = arr[i];
                largestLength = arr[i].length;
            }
        }
        return largestLength;
    }

    function buildASection(
        actionType,
        ctRound,
        numberActions,
        roundParticipants
    ) {
        let round = ctRound;
        for (let j = 1; j <= numberActions; j++) {
            let section2 = document.createElement("div");

            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-" + actionType, j);

            let div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add(
                actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div5.classList.add("center");
            div5.textContent =
                actionType.charAt(0).toUpperCase() +
                actionType.substring(1) +
                (numberActions > 1 ? " #" + j : "");
            let div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add(
                actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div6.classList.add("center");
            div6.textContent = "Hit?";
            let div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add(
                actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div7.classList.add("center");
            div7.textContent = "Target(s)";
            let div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add(
                actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div8.classList.add("center");
            div8.textContent = "hp";
            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);

            roundParticipants.forEach((participant) => {
                let div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add(
                    actionType +
                        (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div9.classList.add("center");
                div9.setAttribute("data-participant", participant.pID);
                let div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add(
                    actionType +
                        (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div10.classList.add("center");
                let div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add(
                    actionType +
                        (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div11.classList.add("center");
                let div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add(
                    actionType +
                        (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div12.classList.add("center");
                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
                round.appendChild(section2);
            });
        }
        return round;
    }

    async function load_encounter() {
        let encounter = await dbQuery("GET", "current_encounter");
        let header = document.querySelector(".main_header");
        header.textContent = `${encounter[0].campaign} - ${encounter[0].location} (${encounter[0].description})`;

        ctApp = await dbQuery("GET", "participants/1");

        // get all the actions of this encounter
        let ctActions = await dbQuery("GET", "actions/1");

        // determine how many rounds are represented in the database
        let totalRounds = ctActions.reduce((max, obj) => {
            return obj.round > max ? obj.round : max;
        }, -Infinity);

        let ct_damages = await dbQuery("GET", "damages/1");
        let damageRounds = ct_damages.reduce((max, obj) => {
            return obj.round > max.round ? obj : max;
        }).round;

        totalRounds = Math.max(totalRounds, damageRounds);
        console.log("real totalRounds is " + totalRounds);

        // start a loop, round.forEach()
        let mainContainer = document.createElement("div");
        for (let i = 1; i <= totalRounds; i++) {
            // determine which of the participants should be in this round
            let roundParticipants = ctApp.filter(
                (participant) =>
                    participant.join_round <= i &&
                    (participant.dead_round || 500) >= i
            );

            // build the wireframe of first section (participants);

            let ctRound = document.createElement("div");
            ctRound.classList.add("ct_round");
            ctRound.setAttribute("data-round", i);

            let section1 = document.createElement("div");
            section1.classList.add("ct_grid4columns");
            section1.setAttribute("data-section", "1");

            let div1 = document.createElement("div");
            div1.classList.add("section");
            div1.classList.add("header");
            div1.classList.add("ct_turn_bookends");
            div1.classList.add("center");
            div1.textContent = "AC";
            let div2 = document.createElement("div");
            div2.classList.add("section");
            div2.classList.add("header");
            div2.classList.add("ct_turn_bookends");
            div2.classList.add("center");
            div2.textContent = "HP";
            let div3 = document.createElement("div");
            div3.classList.add("section");
            div3.classList.add("header");
            div3.classList.add("ct_turn_bookends");
            div3.classList.add("center");
            div3.textContent = "Character";
            let div4 = document.createElement("div");
            div4.classList.add("section");
            div4.classList.add("header");
            div4.classList.add("ct_turn_bookends");
            div4.classList.add("center");
            div4.textContent = "Init";

            section1.appendChild(div1);
            section1.appendChild(div2);
            section1.appendChild(div3);
            section1.appendChild(div4);

            ctRound.appendChild(section1);
            mainContainer.appendChild(ctRound);

            for (let j = 0; j <= roundParticipants.length - 1; j++) {
                let div5 = document.createElement("div");
                div5.classList.add("section");
                div5.classList.add("ct_turn_bookends");
                div5.classList.add("center");
                div5.setAttribute("data-participant", roundParticipants[j].pID);
                let div6 = document.createElement("div");
                div6.classList.add("section");
                div6.classList.add("ct_turn_bookends");
                div6.classList.add("center");
                let div7 = document.createElement("div");
                div7.classList.add("section");
                div7.classList.add("ct_turn_bookends");
                div7.classList.add("center");
                let div8 = document.createElement("div");
                div8.classList.add("section");
                div8.classList.add("ct_turn_bookends");
                div8.classList.add("center");
                section1.appendChild(div5);
                section1.appendChild(div6);
                section1.appendChild(div7);
                section1.appendChild(div8);
            }
            ctRound.appendChild(section1);

            // how many attack, bonus, and react sections are needed for this round?
            let attacksThisRound = [];
            let bonusThisRound = [];
            let reactThisRound = [];
            roundParticipants.forEach((participant) => {
                attacksThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "attack" &&
                            action.round == i
                        );
                    })
                );
            });
            roundParticipants.forEach((participant) => {
                bonusThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "bonus" &&
                            action.round == i
                        );
                    })
                );
            });
            roundParticipants.forEach((participant) => {
                reactThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "react" &&
                            action.round == i
                        );
                    })
                );
            });
            let numAttacks = findLargestSubarray(attacksThisRound);
            numAttacks = Math.max(numAttacks, 1);
            let bonusActions = findLargestSubarray(bonusThisRound);
            let reactActions = findLargestSubarray(reactThisRound);

            // build the attack section(s), empty; we'll fill 'em up at the end of the loop
            let sectionHTML = buildASection(
                "attack",
                ctRound,
                numAttacks,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the bonus section if there is one, empty.
            sectionHTML = buildASection(
                "bonus",
                ctRound,
                bonusActions,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the reaction section if there is one, empty
            sectionHTML = buildASection(
                "react",
                ctRound,
                reactActions,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the final section, empty
            let section2 = document.createElement("div");
            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-section", 2);

            let div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add("ct_turn_bookends");
            div5.classList.add("center");
            div5.textContent = "Drop";
            let div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add("ct_turn_bookends");
            div6.classList.add("align_left");
            div6.textContent = "Start";
            let div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add("ct_turn_bookends");
            div7.classList.add("align_right");
            div7.textContent = "End";
            let div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add("ct_turn_bookends");
            div8.classList.add("center");
            div8.textContent = "Notes";
            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);

            roundParticipants.forEach((participant) => {
                let div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add("ct_turn_bookends");
                div9.classList.add("center");
                div9.setAttribute("div-participant", participant.pID);
                let div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add("ct_turn_bookends");
                div10.classList.add("align_left");
                let div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add("ct_turn_bookends");
                div11.classList.add("align_right");
                let div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add("ct_turn_bookends");
                div12.classList.add("center");
                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
            });
            ctRound.appendChild(section2);

            mainContainer.appendChild(ctRound);
            let headerText = document.createElement("h2");
            headerText.textContent = i == totalRounds ? "" : "Round " + (i + 1);
            mainContainer.appendChild(headerText);

            // populate the sections
            // populate participants

            let participantHTML;
            roundParticipants.forEach(async (participant) => {
                // find latest damage report for this user;
                // if no damages at all, apply participant's starting_hp;
                // else, if no damages for this round, check previous round
                // and so on;

                // figure out hit points by round
                let roundDamages = ct_damages.filter((item) => {
                    return (
                        item.round == i && item.target_pID == participant.pID
                    );
                });
                roundDamages.sort((a, b) => a.tID - b.tID);

                participantHTML = mainContainer.querySelectorAll(
                    '[data-round="' +
                        i +
                        '"] [data-section="1"] [data-participant="' +
                        participant.pID +
                        '"]'
                );

                participantHTML.forEach((turn) => {
                    turn.innerText =
                        participant.ac +
                        (participant.ac_secondary == null
                            ? ""
                            : " / " + participant.ac_secondary);

                    let z = roundDamages.filter((item) => {
                        return item.target_pID == participant.pID;
                    });

                    turn.nextSibling.innerHTML =
                        i === 1 ? `<b>${participant.starting_hp}</b>` : "";

                    // if hit points drop below 50%, yellow background for character in question; if drop to zero, red.
                    z.forEach((item) => {
                        let html;
                        if (item.new_hp <= 0) {
                            turn.classList.add("red");
                            turn.nextSibling.classList.add("red");
                            turn.nextSibling.nextSibling.classList.add("red");
                            turn.nextSibling.nextSibling.nextSibling.classList.add(
                                "red"
                            );
                        } else if (item.new_hp <= participant.starting_hp / 2) {
                            turn.classList.add("yellow");
                            turn.nextSibling.classList.add("yellow");
                            turn.nextSibling.nextSibling.classList.add(
                                "yellow"
                            );
                            turn.nextSibling.nextSibling.nextSibling.classList.add(
                                "yellow"
                            );
                        }

                        turn.nextSibling.innerHTML =
                            turn.nextSibling.innerHTML +
                            (turn.nextSibling.innerText == "" ? "" : ", ") +
                            item.new_hp;
                    });

                    // check to see if participant pID is in roundDamages
                    if (z.length == 0 && i !== 1) {
                        let bobo = ct_damages.filter((item) => {
                            return item.target_pID == participant.pID;
                        });
                        if (bobo.length > 0) {
                            turn.nextSibling.innerText =
                                bobo[bobo.length - 1].new_hp;
                        } else {
                            turn.nextSibling.innerHTML = `<b>${participant.starting_hp}</b>`;
                        }
                    }

                    if (z.length == 0) {
                        let o = findLatestDamage(
                            roundDamages,
                            i,
                            participant.pID,
                            totalRounds
                        );
                        turn.nextSibling.innerHTML =
                            o || `<b>${participant.starting_hp}</b>`;
                    }

                    turn.nextSibling.nextSibling.innerText =
                        participant.character_name +
                        (participant.numeric_value == null
                            ? ""
                            : " #" + participant.numeric_value);
                    turn.nextSibling.nextSibling.nextSibling.innerText =
                        participant.init;
                });

                for (let g = 1; g <= numAttacks; g++) {
                    participantHTML = mainContainer.querySelectorAll(
                        '[data-round="' +
                            i +
                            '"] [data-attack="' +
                            g +
                            '"] [data-participant="' +
                            participant.pID +
                            '"]'
                    );
                    
                    // determine if there is an attack action for this participant this round, and if so, how many
                    let attacks = ctActions.filter((item) => {
                        return item.round == i && item.pID == participant.pID && item.action_type == "attack"
                    })
                    console.log("attacks: " + attacks.length)
                    console.log("actions: " + ctActions[0].action_type)

                    participantHTML.forEach((turn) => {
                        turn.innerText = participant.toolID
                    })
                }
            });
            document.querySelector(".ct_round_container").innerHTML =
                mainContainer.innerHTML;
            // include any ct_tbl_target adjustments for hit points

            console.log(document.querySelector(".ct_round_container"));
        }
    }

    function findLatestDamage(roundDamages, currentRound, pID, totalRounds) {
        let highestValueObj;
        for (let i = totalRounds - 1; i > 0; i--) {
            let p = roundDamages.filter((item) => {
                return (
                    item.round == currentRound && pID == roundDamages.target_pID
                );
            });
            if (p.length > 0) {
                highestValueObj = p.reduce((acc, cur) => {
                    return cur.tID > acc.tID ? cur : acc;
                });
                return highestValueObj;
            } else {
                return "";
            }
        }
    }

    // let numberRounds = Math.max.apply(
    //     Math,
    //     roundActions.map(function (item) {
    //         return item.round;
    //     })
    // );

    // for (let i = 1; i <= numberRounds; i++) {
    //     let mainContainer = document.createElement("div");
    //     let div1 = document.createElement("div");
    //     div1.classList.add("ct_round");
    //     div1.setAttribute("data-round", "1");
    //     let section1 = document.createElement("div");
    //     section1.classList.add("ct_grid4columns");
    //     section1.setAttribute("data-section", "1");

    //     let div2 = document.createElement("div");
    //     div2.classList.add("section");
    //     div2.classList.add("header");
    //     div2.classList.add("ct_turn_bookends");
    //     div2.classList.add("center");
    //     div2.innerText = "AC";
    //     let div3 = document.createElement("div");
    //     div3.classList.add("section");
    //     div3.classList.add("header");
    //     div3.classList.add("ct_turn_bookends");
    //     div3.classList.add("center");
    //     div3.innerText = "HP";
    //     let div4 = document.createElement("div");
    //     div4.classList.add("section");
    //     div4.classList.add("header");
    //     div4.classList.add("ct_turn_bookends");
    //     div4.classList.add("center");
    //     div4.innerText = "Character";
    //     let div5 = document.createElement("div");
    //     div5.classList.add("section");
    //     div5.classList.add("header");
    //     div5.classList.add("ct_turn_bookends");
    //     div5.classList.add("center");
    //     div5.innerText = "Init";

    //     section1.appendChild(div2);
    //     section1.appendChild(div3);
    //     section1.appendChild(div4);
    //     section1.appendChild(div5);

    //     // determine participants for this round
    //     roundParticipants = ctApp.filter((participant) => {
    //         return (
    //             i >= participant.join_round && i <= participant.dead_round
    //         );
    //     });

    //     let div6, div7, div8, div9;
    //     roundParticipants.forEach((participant) => {
    //         div6 = document.createElement("div");
    //         div6.classList.add("section");
    //         div6.classList.add("ct_turn_bookends");
    //         div6.classList.add("center");
    //         div6.setAttribute("data-participant", participant.pID);
    //         div7 = document.createElement("div");
    //         div7.classList.add("section");
    //         div7.classList.add("ct_turn_bookends");
    //         div7.classList.add("center");
    //         div8 = document.createElement("div");
    //         div8.classList.add("section");
    //         div8.classList.add("ct_turn_bookends");
    //         div8.classList.add("center");
    //         div9 = document.createElement("div");
    //         div9.classList.add("section");
    //         div9.classList.add("ct_turn_bookends");
    //         div9.classList.add("center");
    //         section1.appendChild(div6);
    //         section1.appendChild(div7);
    //         section1.appendChild(div8);
    //         section1.appendChild(div9);
    //     });

    //     div1.appendChild(section1);
    //     mainContainer.appendChild(div1);

    //     document.querySelector(".ct_round_container").innerHTML =
    //         mainContainer.innerHTML;

    //     let hitPoints = await dbQuery("GET", "hitPoints/1/" + i);

    //     let participantTurn;
    //     roundParticipants.forEach((participant) => {
    //         participantTurn = mainContainer.querySelector(
    //             '[data-participant="' + participant.pID + '"]'
    //         );
    //         participantTurn.innerText =
    //             participant.AC +
    //             (participant.AC_secondary == null
    //                 ? ""
    //                 : " / " + participant.AC_secondary);
    //         participantTurn.nextSibling.innerText = getHitPointsByRound(
    //             i,
    //             participant.pID
    //         );
    //         participantTurn.nextSibling.nextSibling.innerText =
    //             participant.character_name +
    //             (participant.numeric_ID == null
    //                 ? ""
    //                 : " #" + participant.numeric_ID);
    //         participantTurn.nextSibling.nextSibling.nextSibling.innerText =
    //             participant.init;
    //     });

    //     function getHitPointsByRound(round, pID) {
    //         let hpText = "";
    //         let y = hitPoints.filter((participant) => {
    //             return participant.pID == pID;
    //         });
    //         y.forEach((item, index) => {
    //             hpText = hpText + (index == 0 ? "" : ", ") + item.hp;
    //         });
    //         return hpText;
    //     }
    //     console.log("got here here here");
    //     // populate participants' hit points cells
    //     let hpHTML;
    //     console.log(roundParticipants);
    //     roundParticipants.forEach((participant) => {
    //         hpHTML = document.querySelector(
    //             '[data-round="' +
    //                 i +
    //                 '"] [data-participant="' +
    //                 participant.pID +
    //                 '"]'
    //         );
    //         let obj = hitPoints.filter((hp) => {
    //             return hp.pID == participant.pID;
    //         });
    //         obj.forEach((object) => {
    //             if (hpHTML.nextSibling.innerText == "undefined" || "") {
    //                 hpHTML.nextSibling.innerText = object.hp;
    //             } else {
    //                 hpHTML.nextSibling.innerText =
    //                     hpHTML.nextSibling.innerText + ", " + object.hp;
    //             }
    //         });
    //     });

    //     // build section 2

    //     // get info about rounds and turns
    //     let actionTurns = await dbQuery("GET", "turns");
    //     let attacksThisRound = [];
    //     let bonusThisRound = [];
    //     let reactThisRound = [];
    //     console.log(actionTurns);
    //     // how many attack, bonus, and react sections are needed for this round?
    //     roundParticipants.forEach((participant) => {
    //         attacksThisRound.push(
    //             actionTurns.filter((turn) => {
    //                 return (
    //                     turn.pID == participant.pID &&
    //                     turn.action_type == "attack"
    //                 );
    //             })
    //         );
    //     });
    //     roundParticipants.forEach((participant) => {
    //         bonusThisRound.push(
    //             actionTurns.filter((turn) => {
    //                 return (
    //                     turn.pID == participant.pID &&
    //                     turn.action_type == "bonus"
    //                 );
    //             })
    //         );
    //     });
    //     roundParticipants.forEach((participant) => {
    //         reactThisRound.push(
    //             actionTurns.filter((turn) => {
    //                 return (
    //                     turn.pID == participant.pID &&
    //                     turn.action_type == "react"
    //                 );
    //             })
    //         );
    //     });
    //     function findLargestSubarray(arr) {
    //         let largestSubarray = arr[0];
    //         let largestLength = arr[0].length;
    //         for (let i = 1; i < arr.length; i++) {
    //             if (arr[i].length > largestLength) {
    //                 largestSubarray = arr[i];
    //                 largestLength = arr[i].length;
    //             }
    //         }
    //         return largestLength;
    //     }

    //     // here are the variables describing how many action sections to build for this round
    //     let numAttacks = findLargestSubarray(attacksThisRound);
    //     let bonusActions = findLargestSubarray(bonusThisRound);
    //     let reactActions = findLargestSubarray(reactThisRound);

    //     // build attack section(s)
    //     for (let i = 1; i <= numAttacks; i++) {
    //         let section2 = document.createElement("div");
    //         section2.classList.add("ct_grid4columns");
    //         section2.setAttribute("data-attack", i);

    //         // headers
    //         let div10 = document.createElement("div");
    //         div10.classList.add("section");
    //         div10.classList.add("header");
    //         div10.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //         div10.classList.add("center");
    //         div10.innerText = "Attack" + (numAttacks > 1 ? " #" + i : "");
    //         let div11 = document.createElement("div");
    //         div11.classList.add("section");
    //         div11.classList.add("header");
    //         div11.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //         div11.classList.add("center");
    //         div11.innerText = "Hit?";
    //         let div12 = document.createElement("div");
    //         div12.classList.add("section");
    //         div12.classList.add("header");
    //         div12.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //         div12.classList.add("center");
    //         div12.innerText = "Target(s)";
    //         let div13 = document.createElement("div");
    //         div13.classList.add("section");
    //         div13.classList.add("header");
    //         div13.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //         div13.classList.add("center");
    //         div13.innerText = "hp";

    //         section2.appendChild(div10);
    //         section2.appendChild(div11);
    //         section2.appendChild(div12);
    //         section2.appendChild(div13);

    //         // build rows of attack(s)
    //         roundParticipants.forEach((participant) => {
    //             let div14 = document.createElement("div");
    //             div14.classList.add("section");
    //             div14.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //             div14.classList.add("center");
    //             div14.setAttribute("data-participant", participant.pID);
    //             let div15 = document.createElement("div");
    //             div15.classList.add("section");
    //             div15.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //             div15.classList.add("center");
    //             let div16 = document.createElement("div");
    //             div16.classList.add("section");
    //             div16.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //             div16.classList.add("center");
    //             let div17 = document.createElement("div");
    //             div17.classList.add("section");
    //             div17.classList.add("attack" + (i % 2 ? "" : "_alt"));
    //             div17.classList.add("center");

    //             section2.appendChild(div14);
    //             section2.appendChild(div15);
    //             section2.appendChild(div16);
    //             section2.appendChild(div17);

    //             div1.appendChild(section2);
    //         });

    //         mainContainer.appendChild(div1);
    //         document.querySelector(".ct_round_container").innerHTML =
    //             mainContainer.innerHTML;
    //     }

    //     // build bonus section
    //     for (let i = 1; i <= bonusActions; i++) {
    //         let section3 = document.createElement("div");
    //         section3.classList.add("ct_grid4columns");
    //         section3.setAttribute("data-bonus", i);

    //         // headers
    //         let div18 = document.createElement("div");
    //         div18.classList.add("section");
    //         div18.classList.add("header");
    //         div18.classList.add("bonus");
    //         div18.classList.add("center");
    //         div18.innerText = "Bonus";
    //         let div19 = document.createElement("div");
    //         div19.classList.add("section");
    //         div19.classList.add("header");
    //         div19.classList.add("bonus");
    //         div19.classList.add("center");
    //         div19.innerText = "Hit?";
    //         let div20 = document.createElement("div");
    //         div20.classList.add("section");
    //         div20.classList.add("header");
    //         div20.classList.add("bonus");
    //         div20.classList.add("center");
    //         div20.innerText = "Target(s)";
    //         let div21 = document.createElement("div");
    //         div21.classList.add("section");
    //         div21.classList.add("header");
    //         div21.classList.add("bonus");
    //         div21.classList.add("center");
    //         div21.innerText = "hp";

    //         section3.appendChild(div18);
    //         section3.appendChild(div19);
    //         section3.appendChild(div20);
    //         section3.appendChild(div21);

    //         roundParticipants.forEach((participant) => {
    //             let div22 = document.createElement("div");
    //             div22.classList.add("section");
    //             div22.classList.add("bonus");
    //             div22.classList.add("center");
    //             div22.setAttribute("data-participant", participant.pID);
    //             let div23 = document.createElement("div");
    //             div23.classList.add("section");
    //             div23.classList.add("bonus");
    //             div23.classList.add("center");
    //             let div24 = document.createElement("div");
    //             div24.classList.add("section");
    //             div24.classList.add("bonus");
    //             div24.classList.add("center");
    //             let div25 = document.createElement("div");
    //             div25.classList.add("section");
    //             div25.classList.add("bonus");
    //             div25.classList.add("center");

    //             section3.appendChild(div22);
    //             section3.appendChild(div23);
    //             section3.appendChild(div24);
    //             section3.appendChild(div25);

    //             div1.appendChild(section3);
    //         });
    //         mainContainer.appendChild(div1);
    //         document.querySelector(".ct_round_container").innerHTML =
    //             mainContainer.innerHTML;
    //     }

    //     // build reaction section
    //     for (let i = 1; i <= reactActions; i++) {
    //         let section4 = document.createElement("div");
    //         section4.classList.add("ct_grid4columns");
    //         section4.setAttribute("data-react", i);

    //         // headers
    //         let div26 = document.createElement("div");
    //         div26.classList.add("section");
    //         div26.classList.add("header");
    //         div26.classList.add("reaction");
    //         div26.classList.add("center");
    //         div26.innerText = "React";
    //         let div27 = document.createElement("div");
    //         div27.classList.add("section");
    //         div27.classList.add("header");
    //         div27.classList.add("reaction");
    //         div27.classList.add("center");
    //         div27.innerText = "Hit?";
    //         let div28 = document.createElement("div");
    //         div28.classList.add("section");
    //         div28.classList.add("header");
    //         div28.classList.add("reaction");
    //         div28.classList.add("center");
    //         div28.innerText = "Target(s)";
    //         let div29 = document.createElement("div");
    //         div29.classList.add("section");
    //         div29.classList.add("header");
    //         div29.classList.add("reaction");
    //         div29.classList.add("center");
    //         div29.innerText = "hp";

    //         section4.appendChild(div26);
    //         section4.appendChild(div27);
    //         section4.appendChild(div28);
    //         section4.appendChild(div29);

    //         roundParticipants.forEach((participant) => {
    //             let div30 = document.createElement("div");
    //             div30.classList.add("section");
    //             div30.classList.add("reaction");
    //             div30.classList.add("center");
    //             div30.setAttribute("data-participant", participant.pID);
    //             let div31 = document.createElement("div");
    //             div31.classList.add("section");
    //             div31.classList.add("reaction");
    //             div31.classList.add("center");
    //             let div32 = document.createElement("div");
    //             div32.classList.add("section");
    //             div32.classList.add("reaction");
    //             div32.classList.add("center");
    //             let div33 = document.createElement("div");
    //             div33.classList.add("section");
    //             div33.classList.add("reaction");
    //             div33.classList.add("center");

    //             section4.appendChild(div30);
    //             section4.appendChild(div31);
    //             section4.appendChild(div32);
    //             section4.appendChild(div33);

    //             div1.appendChild(section4);
    //         });
    //         mainContainer.appendChild(div1);
    //         document.querySelector(".ct_round_container").innerHTML =
    //             mainContainer.innerHTML;
    //     }

    //     // build start-end section
    //     let section5 = document.createElement("div");
    //     section5.classList.add("ct_grid4columns");
    //     section5.setAttribute("data-section", 2);

    //     // headers
    //     let div34 = document.createElement("div");
    //     div34.classList.add("section");
    //     div34.classList.add("header");
    //     div34.classList.add("ct_turn_bookends");
    //     div34.classList.add("center");
    //     div34.innerText = "Drop";
    //     let div35 = document.createElement("div");
    //     div35.classList.add("section");
    //     div35.classList.add("header");
    //     div35.classList.add("ct_turn_bookends");
    //     div35.classList.add("center");
    //     div35.innerText = "Start";
    //     let div36 = document.createElement("div");
    //     div36.classList.add("section");
    //     div36.classList.add("header");
    //     div36.classList.add("ct_turn_bookends");
    //     div36.classList.add("center");
    //     div36.innerText = "End";
    //     let div37 = document.createElement("div");
    //     div37.classList.add("section");
    //     div37.classList.add("header");
    //     div37.classList.add("ct_turn_bookends");
    //     div37.classList.add("center");
    //     div37.innerText = "Notes";

    //     section5.appendChild(div34);
    //     section5.appendChild(div35);
    //     section5.appendChild(div36);
    //     section5.appendChild(div37);

    //     roundParticipants.forEach((participant) => {
    //         let div38 = document.createElement("div");
    //         div38.classList.add("section");
    //         div38.classList.add("ct_turn_bookends");
    //         div38.classList.add("center");
    //         div38.setAttribute("data-participant", participant.pID);
    //         let div39 = document.createElement("div");
    //         div39.classList.add("section");
    //         div39.classList.add("ct_turn_bookends");
    //         div39.classList.add("center");
    //         let div40 = document.createElement("div");
    //         div40.classList.add("section");
    //         div40.classList.add("ct_turn_bookends");
    //         div40.classList.add("center");
    //         let div41 = document.createElement("div");
    //         div41.classList.add("section");
    //         div41.classList.add("ct_turn_bookends");
    //         div41.classList.add("center");

    //         section5.appendChild(div38);
    //         section5.appendChild(div39);
    //         section5.appendChild(div40);
    //         section5.appendChild(div41);

    //         div1.appendChild(section5);
    //     });
    //     mainContainer.appendChild(div1);
    //     document.querySelector(".ct_round_container").innerHTML =
    //         mainContainer.innerHTML;
    //     console.log(mainContainer);

    //     // populate attacks
    //     console.log(actionTurns);
    //     const attackDivs = document.querySelectorAll("[data-attack]");
    //     let attackIndex = 0;

    //     let yyy = await dbQuery("GET","participantActions/1/" + i)

    //     actionTurns.forEach((action) => {
    //         const attackDiv = attackDivs[attackIndex];
    //         console.log(attackDivs);
    //         const participantDiv =
    //             attackDiv.querySelector("[data-participant]");
    //         if (participantDiv) {
    //             let participantText = participantDiv.innerText;
    //             if (participantText == "") {
    //                 participantDiv.innerText = action.toolName;
    //                 participantDiv.nextSibling.innerText =
    //                     action.hit == 0 ? "" : "X";
    //                 participantDiv.nextSibling.nextSibling.innerText =
    //                     roundParticipants.find(participant => participant.pID === action.targetID).character_name
    //             } else {
    //                 // Handle case where participantDiv already has content
    //             }
    //         }
    //         attackIndex++; // Increment index for next iteration
    //     });

    // if action is an attack, determine first available attack section
    // querySelector first open attack section
    // populate attack section

    // if action is not an attack, assign it appropriately
    // }
</script>











