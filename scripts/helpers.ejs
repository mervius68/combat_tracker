<script>
    let cellCountVertical = 1;
    async function dbQuery(httpReqType, httpReqString) {
        // arguments should look something like "GET" and "getSomethingFromBackEnd/42/true"
        let dbReturn = makePromise(httpReqType, httpReqString);
        let dbReturnJSON = await dbReturn;
        let unpackdbReturn = JSON.parse(dbReturnJSON);
        return unpackdbReturn;

        function makePromise(httpReqType, httpReqString) {
            httpReqString = httpReqString;
            let request = new Promise((resolve, reject) => {
                let xhr = new XMLHttpRequest();
                xhr.open(httpReqType, "../" + httpReqString, true);
                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const text = xhr.responseText;
                        resolve(text);
                    } else {
                        reject(xhr.statusText);
                    }
                };
                xhr.onerror = () => reject("Request Failed");
                xhr.send();
            });
            return request;
        }
    }

    function findLargestSubarray(arr) {
        let largestSubarray = arr[0];
        let largestLength = arr[0].length;
        for (let i = 1; i < arr.length; i++) {
            if (arr[i].length > largestLength) {
                largestSubarray = arr[i];
                largestLength = arr[i].length;
            }
        }
        return largestLength;
    }

    function buildASection(
        actionType,
        ctRound,
        numberActions,
        roundParticipants
    ) {
        let round = ctRound;
        for (let j = 1; j <= numberActions; j++) {
            let section2 = document.createElement("div");

            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-" + actionType, j);

            let div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add(
                actionType +
                (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div5.classList.add("center");
            div5.textContent =
                actionType.charAt(0).toUpperCase() +
                actionType.substring(1) +
                (numberActions > 1 ? " #" + j : "");
            let div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add(
                actionType +
                (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div6.classList.add("center");
            div6.textContent = "Hit?";
            let div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add(
                actionType +
                (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div7.classList.add("center");
            div7.textContent = "Target(s)";
            let div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add(
                actionType +
                (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
            );
            div8.classList.add("center");
            div8.textContent = "hp";
            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);
            roundParticipants.forEach((participant) => {
                let div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add(
                    actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div9.classList.add("center");
                div9.setAttribute("data-participant", participant.pID);
                let div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add(
                    actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div10.classList.add("center");
                let div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add(
                    actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div11.classList.add("center");
                let div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add(
                    actionType +
                    (actionType == "attack" && j % 2 == 0 ? "_alt" : "")
                );
                div12.classList.add("center");
                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
                round.appendChild(section2);
            });
        }
        return round;
    }

    async function load_encounter() {
        let htm = await getTurnModal();
        // Swal.fire({
        //     title: 'Round 1! Honza! Let\'s do this!',
        //     html: htm,
        //     showCancelButton: true,
        //     confirmButtonText: "Submit"
        // })
        let encounter = await dbQuery("GET", "current_encounter");
        let header = document.querySelector(".main_header");
        header.textContent = `${encounter[0].campaign} - ${encounter[0].location} (${encounter[0].description})`;

        ctApp = await dbQuery("GET", "participants/1");

        // get all the actions of this encounter
        let ctActions = await dbQuery("GET", "actions/1");

        // determine how many rounds are represented in the database
        let totalRounds = ctActions.reduce((max, obj) => {
            return obj.round > max ? obj.round : max;
        }, -Infinity);

        let ct_damages = await dbQuery("GET", "damages/1");
        let damageRounds = ct_damages.reduce((max, obj) => {
            return obj.round > max.round ? obj : max;
        }).round;

        totalRounds = Math.max(totalRounds, damageRounds);

        // start a loop, round.forEach()
        let mainContainer = document.createElement("div");
        for (let i = 1; i <= totalRounds; i++) {
            // determine which of the participants should be in this round
            let roundParticipants = ctApp.filter(
                (participant) =>
                    participant.join_round <= i &&
                    (participant.dead_round || 500) >= i
            );

            // build the wireframe of first section (participants);

            let ctRound = document.createElement("div");
            ctRound.classList.add("ct_round");
            ctRound.setAttribute("data-round", i);

            let section1 = document.createElement("div");
            section1.classList.add("ct_grid4columns");
            section1.setAttribute("data-section", "1");

            let div1 = document.createElement("div");
            div1.classList.add("section");
            div1.classList.add("header");
            div1.classList.add("ct_turn_bookends");
            div1.classList.add("center");
            div1.textContent = "AC";
            let div2 = document.createElement("div");
            div2.classList.add("section");
            div2.classList.add("header");
            div2.classList.add("ct_turn_bookends");
            div2.classList.add("center");
            div2.textContent = "HP";
            let div3 = document.createElement("div");
            div3.classList.add("section");
            div3.classList.add("header");
            div3.classList.add("ct_turn_bookends");
            div3.classList.add("center");
            div3.textContent = "Character";
            let div4 = document.createElement("div");
            div4.classList.add("section");
            div4.classList.add("header");
            div4.classList.add("ct_turn_bookends");
            div4.classList.add("center");
            div4.textContent = "Init";

            section1.appendChild(div1);
            section1.appendChild(div2);
            section1.appendChild(div3);
            section1.appendChild(div4);

            ctRound.appendChild(section1);
            mainContainer.appendChild(ctRound);

            for (let j = 0; j <= roundParticipants.length - 1; j++) {
                let div5 = document.createElement("div");
                div5.classList.add("section");
                div5.classList.add("ct_turn_bookends");
                div5.classList.add("center");
                div5.setAttribute("data-participant", roundParticipants[j].pID);
                div5.setAttribute('data-nav', cellCountVertical)
                div5.setAttribute('data-round', i)
                cellCountVertical += 1;
                let div6 = document.createElement("div");
                div6.classList.add("section");
                div6.classList.add("ct_turn_bookends");
                div6.classList.add("center");
                let div7 = document.createElement("div");
                div7.classList.add("section");
                div7.classList.add("ct_turn_bookends");
                div7.classList.add("center");
                let div8 = document.createElement("div");
                div8.classList.add("section");
                div8.classList.add("ct_turn_bookends");
                div8.classList.add("center");
                section1.appendChild(div5);
                section1.appendChild(div6);
                section1.appendChild(div7);
                section1.appendChild(div8);
            }
            ctRound.appendChild(section1);

            // how many attack, bonus, and react sections are needed for this round?
            let attacksThisRound = [];
            let bonusThisRound = [];
            let reactThisRound = [];
            roundParticipants.forEach((participant) => {
                attacksThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "attack" &&
                            action.round == i
                        );
                    })
                );
            });
            roundParticipants.forEach((participant) => {
                bonusThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "bonus" &&
                            action.round == i
                        );
                    })
                );
            });
            roundParticipants.forEach((participant) => {
                reactThisRound.push(
                    ctActions.filter((action) => {
                        return (
                            action.pID == participant.pID &&
                            action.action_type == "react" &&
                            action.round == i
                        );
                    })
                );
            });
            let numAttacks = findLargestSubarray(attacksThisRound);
            numAttacks = Math.max(numAttacks, 1);
            let bonusActions = findLargestSubarray(bonusThisRound);
            let reactActions = findLargestSubarray(reactThisRound);

            // build the attack section(s), empty; we'll fill 'em up at the end of the loop
            let sectionHTML = buildASection(
                "attack",
                ctRound,
                numAttacks,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the bonus section if there is one, empty.
            sectionHTML = buildASection(
                "bonus",
                ctRound,
                bonusActions,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the reaction section if there is one, empty
            sectionHTML = buildASection(
                "react",
                ctRound,
                reactActions,
                roundParticipants
            );
            mainContainer.appendChild(sectionHTML);

            // build the final section, empty
            let section2 = document.createElement("div");
            section2.classList.add("ct_grid4columns");
            section2.setAttribute("data-section", 2);

            let div5 = document.createElement("div");
            div5.classList.add("section");
            div5.classList.add("header");
            div5.classList.add("ct_turn_bookends");
            div5.classList.add("center");
            div5.textContent = "Drop";
            let div6 = document.createElement("div");
            div6.classList.add("section");
            div6.classList.add("header");
            div6.classList.add("ct_turn_bookends");
            div6.classList.add("align_left");
            div6.textContent = "Start";
            let div7 = document.createElement("div");
            div7.classList.add("section");
            div7.classList.add("header");
            div7.classList.add("ct_turn_bookends");
            div7.classList.add("align_right");
            div7.textContent = "End";
            let div8 = document.createElement("div");
            div8.classList.add("section");
            div8.classList.add("header");
            div8.classList.add("ct_turn_bookends");
            div8.classList.add("center");
            div8.textContent = "Notes";
            section2.appendChild(div5);
            section2.appendChild(div6);
            section2.appendChild(div7);
            section2.appendChild(div8);

            roundParticipants.forEach((participant) => {
                let div9 = document.createElement("div");
                div9.classList.add("section");
                div9.classList.add("ct_turn_bookends");
                div9.classList.add("center");
                div9.setAttribute("div-participant", participant.pID);
                let div10 = document.createElement("div");
                div10.classList.add("section");
                div10.classList.add("ct_turn_bookends");
                div10.classList.add("align_left");
                let div11 = document.createElement("div");
                div11.classList.add("section");
                div11.classList.add("ct_turn_bookends");
                div11.classList.add("align_right");
                let div12 = document.createElement("div");
                div12.classList.add("section");
                div12.classList.add("ct_turn_bookends");
                div12.classList.add("center");
                section2.appendChild(div9);
                section2.appendChild(div10);
                section2.appendChild(div11);
                section2.appendChild(div12);
            });
            ctRound.appendChild(section2);

            mainContainer.appendChild(ctRound);
            let headerText = document.createElement("h2");
            headerText.textContent = i == totalRounds ? "" : "Round " + (i + 1);
            mainContainer.appendChild(headerText);

            // populate the sections
            let roundActions = ctActions.filter((action) => {
                return action.round == i
            })

            // populate participants
            // let participantHTML;
            roundParticipants.forEach(async (participant) => {
                // find latest damage report for this user;
                // if no damages at all, apply participant's starting_hp;
                // else, if no damages for this round, check previous round
                // and so on;

                // figure out hit points by round
                let roundDamages = ct_damages.filter((item) => {
                    return (
                        item.round == i && item.target_pID == participant.pID
                    );
                });
                // sort oldest to newest, e.g. hit points cell might read "22, 15, 13" (hp descending as they take hits)
                roundDamages.sort((a, b) => a.tID - b.tID);

                // locate the HTML elements for this participant
                participantHTML = mainContainer.querySelectorAll(
                    '[data-round="' +
                    i +
                    '"] [data-section="1"] [data-participant="' +
                    participant.pID +
                    '"]'
                );

                //     // for each HTML element that goes with this participant...
                participantHTML.forEach((turn, index) => {
                    turn.innerText =
                        participant.ac +
                        (participant.ac_secondary == null
                            ? ""
                            : " / " + participant.ac_secondary);

                    let damageObjects = roundDamages.filter((item) => {
                        return item.target_pID == participant.pID;
                    });

                    // put starting hp on the board
                    turn.nextSibling.innerHTML =
                        i === 1 ? `<b>${participant.starting_hp}</b>` : "";

                    // if hit points drop below 50%, yellow background for character in question; if drop to zero, red.
                    let carryForwardHP = ""
                    damageObjects.forEach((item) => {
                        let html;
                        if (item.new_hp <= 0) {
                            turn.classList.add("red");
                            turn.nextSibling.classList.add("red");
                            turn.nextSibling.nextSibling.classList.add("red");
                            turn.nextSibling.nextSibling.nextSibling.classList.add(
                                "red"
                            );
                        } else if (item.new_hp <= participant.starting_hp / 2) {
                            turn.classList.add("yellow");
                            turn.nextSibling.classList.add("yellow");
                            turn.nextSibling.nextSibling.classList.add(
                                "yellow"
                            );
                            turn.nextSibling.nextSibling.nextSibling.classList.add(
                                "yellow"
                            );
                        }

                        try {
                            let paypay = mainContainer.querySelector('[data-round="' + (i - 1) + '"] [data-section="1"] [data-participant="' + participant.pID + '"]');
                            const arr = paypay.nextSibling.innerHTML.split(","); // split the string into an array based on comma delimiter
                            const lastNum = arr.pop().trim(); // remove and return the last element of the array, and trim any whitespace
                            console.log(lastNum); // output: "12"
                            carryForwardHP = lastNum;
                        }
                        catch (err) { }

                        // add hit points for this row
                        turn.nextSibling.innerHTML = carryForwardHP + (carryForwardHP != "" ? ", " : "") +
                            turn.nextSibling.innerHTML +
                            (turn.nextSibling.innerText == "" ? "" : ", ") +
                            item.new_hp;
                    });

                    // check to see if participant pID is in roundDamages
                    if (damageObjects.length == 0 && i !== 1) {
                        let damageCheck = ct_damages.filter((item) => {
                            return item.target_pID == participant.pID;
                        });
                        if (damageCheck.length > 0) {
                            turn.nextSibling.innerText =
                                damageCheck[damageCheck.length - 1].new_hp;
                        } else {
                            turn.nextSibling.innerHTML = `<b>${participant.starting_hp}</b>`;
                        }
                    }
                    // if they haven't taken damage this round...
                    // if (damageObjects.length == 0) {

                    //     // get last round's latest hp

                    //     turn.nextSibling.innerHTML =
                    //         `<b>${participant.starting_hp}</b>`
                    // }

                    turn.nextSibling.nextSibling.innerText =
                        participant.character_name +
                        (participant.numeric_value == null
                            ? ""
                            : " #" + participant.numeric_value);
                    turn.nextSibling.nextSibling.nextSibling.innerText =
                        participant.init;
                });
            });
        }

        for (const action of ctActions) {
            let tool = await dbQuery("GET", "tool/" + action.toolID);
            let target = await dbQuery("GET", "target/" + action.targetID);
            let targets = await dbQuery("GET", "targets/" + target[0].targetID)
            let targetString = "";
            let damageString = "";
            targets.forEach((item, index) => {
                targetString += (index > 0 ? " / " : "") + item.character_name + (item.numeric_value != 0 ? " #" + item.numeric_value : "")
                damageString += (index > 0 ? " / " : "") + item.damage
            })
            let actionArray = []
            actionArray[0] = tool[0].toolName;
            actionArray[1] = action.hit == 1 ? "X" : "";
            actionArray[2] = targetString
            actionArray[3] = damageString
            await sendToCoordinate(action.round, action.pID, action.action_type, actionArray);
        }



        function sendToCoordinate(round, participant, actionType, actionArray) {
            let actionHTML = "data-" + actionType
            let action = 1;
            let x;
            do {
                x = mainContainer.querySelector(`[data-round="${round}"] [${actionHTML}="${action}"] [data-participant="${participant}"]`);
                action += 1;
            } while (x.innerHTML !== "");
            x.innerHTML = actionArray[0]
            x.nextSibling.innerHTML = actionArray[1]
            x.nextSibling.nextSibling.innerHTML = actionArray[2]
            x.nextSibling.nextSibling.nextSibling.innerHTML = actionArray[3]
        }

        document.querySelector(".ct_round_container").innerHTML =
            mainContainer.innerHTML;
        let startNav = document.querySelector('[data-nav="1"]')
        startNav.classList.add("selected")
        startNav.nextSibling.classList.add("selected")
        startNav.nextSibling.nextSibling.classList.add("selected")
        startNav.nextSibling.nextSibling.nextSibling.classList.add("selected")
        navify()
    }

    function navify() {
        document.addEventListener('keydown', function (event) {
            // Check if the key pressed was the down arrow
            if (event.key === 'ArrowDown') {
                let myElement = document.querySelectorAll(".selected");
                let nav = myElement[0].getAttribute("data-nav");
                let targetNum = Number(nav) + 1;
                if (nav < cellCountVertical - 1) {
                    myElement.forEach((ele) => {
                        ele.classList.remove("selected");
                    })
                    let newTarget = document.querySelector('[data-nav="' + targetNum + '"]');
                    console.log(targetNum)
                    newTarget.classList.add("selected")
                    newTarget.nextSibling.classList.add("selected")
                    newTarget.nextSibling.nextSibling.classList.add("selected")
                    newTarget.nextSibling.nextSibling.nextSibling.classList.add("selected")
                }
            }
        });
        document.addEventListener('keydown', function (event) {
            // Check if the key pressed was the up arrow
            if (event.key === 'ArrowUp') {
                let myElement = document.querySelectorAll(".selected");
                let nav = myElement[0].getAttribute("data-nav");
                let targetNum = Number(nav) - 1;
                if (nav != 1) {
                    myElement.forEach((ele) => {
                        ele.classList.remove("selected");
                    })
                    let newTarget = document.querySelector('[data-nav="' + targetNum + '"]');
                    console.log(newTarget)
                    newTarget.classList.add("selected")
                    newTarget.nextSibling.classList.add("selected")
                    newTarget.nextSibling.nextSibling.classList.add("selected")
                    newTarget.nextSibling.nextSibling.nextSibling.classList.add("selected")
                }
            }
        });

    }

    function move() {
        let selected = document.querySelector(".selected");
        selected.nextSibling.nextSibling.nextSibling.classList.add(".selected");
    }

    function findLatestDamage(roundDamages, currentRound, pID, totalRounds) {
        let highestValueObj;
        for (let i = totalRounds - 1; i > 0; i--) {
            let p = roundDamages.filter((item) => {
                return (
                    item.round == currentRound && pID == roundDamages.target_pID
                );
            });

            console.log(p.length)
            if (p.length > 0) {
                highestValueObj = p.reduce((acc, cur) => {
                    return cur.tID > acc.tID ? cur : acc;
                });
                console.log(highestValueObj)
                return highestValueObj;
            } else {
                return "";
            }
        }
    }

    async function getTurnModal() {
        return "Happy Joy"
    }

    async function selectRow() {
        let row = document.querySelector('[data-round="1"] [data-section="1"] [data-participant="2"]')
        row.classList.add("selected");
        row.nextSibling.classList.add("selected")
        row.nextSibling.nextSibling.classList.add("selected")
        row.nextSibling.nextSibling.nextSibling.classList.add("selected")
    }
</script>