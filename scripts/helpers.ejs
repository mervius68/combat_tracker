<script>
    async function dbQuery(httpReqType, httpReqString) {
        // arguments should look something like "GET" and "getSomethingFromBackEnd/42/true"
        let dbReturn = makePromise(httpReqType, httpReqString);
        let dbReturnJSON = await dbReturn;
        let unpackdbReturn = JSON.parse(dbReturnJSON);
        return unpackdbReturn;

        function makePromise(httpReqType, httpReqString) {
            httpReqString = httpReqString;
            let request = new Promise((resolve, reject) => {
                let xhr = new XMLHttpRequest();
                xhr.open(httpReqType, "../" + httpReqString, true);
                xhr.onload = () => {
                    if (xhr.status === 200) {
                        const text = xhr.responseText;
                        resolve(text);
                    } else {
                        reject(xhr.statusText);
                    }
                };
                xhr.onerror = () => reject("Request Failed");
                xhr.send();
            });
            return request;
        }
    }

    async function load_encounter() {
        // get participants
        ctApp = await dbQuery("GET", "participants");
        console.log(ctApp);
        // get basic encounter details
        let campaign = await dbQuery("GET", "current_encounter");
        let header = document.querySelector(".main_header");
        header.textContent = `${campaign[0].campaign} - ${campaign[0].location}`;

        // get info about rounds and turns
        let turns = await dbQuery("GET", "turns");

        // determine how many rounds there are
        let numberRounds = Math.max.apply(
            Math,
            turns.map(function (item) {
                return item.round;
            })
        );
        console.log("number of rounds: " + numberRounds)

        // determine how many participants
        let numberParticipants = ctApp.length;
        console.log("number of participants: " + numberParticipants)

        // determine types and number of attacks
        let attacks, bonus, react, maxAttacks, maxBonus, maxReact, roundWireFrame;
        turns.forEach(() => {
            attacks = turns.filter((turn) => {
                return (
                    turn.roundID == 1 &&
                    turn.pID == 1 &&
                    turn.action_type == "attack"
                );
            }).length;
            bonus = turns.filter((turn) => {
                return (
                    turn.roundID == 1 &&
                    turn.pID == 1 &&
                    turn.action_type == "bonus"
                );
            }).length;
            react = turns.filter((turn) => {
                return (
                    turn.roundID == 1 &&
                    turn.pID == 1 &&
                    turn.action_type == "react"
                );
            }).length;
            
            maxAttacks = maxAttacks > attacks ? maxAttacks : attacks;
            maxBonus = maxBonus > bonus ? maxBonus : bonus;
            maxReact = maxReact > react ? maxReact : react;

            roundWireFrame = {
                round: 1,
                attacks: maxAttacks,
                bonus: maxBonus,
                react: maxReact
            }
            console.log(roundWireFrame)
        });


        function determineNumbersOfNeededActionTables(turns, round, pID, actionType) {
            for (let i = 0; i < numberRounds; i++) {
                turns.forEach((item) => {
                    attacks = turns.filter((turn) => {
                        return (
                            turn.roundID == 1 &&
                            turn.pID == 1 &&
                            turn.action_type == "attack"
                        );
                    }).length;
                    bonus = turns.filter((turn) => {
                        return (
                            turn.roundID == 1 &&
                            turn.pID == 1 &&
                            turn.action_type == "bonus"
                        );
                    }).length;
                    react = turns.filter((turn) => {
                        return (
                            turn.roundID == 1 &&
                            turn.pID == 1 &&
                            turn.action_type == "react"
                        );
                    }).length;
                    maxAttacks = maxAttacks > attacks ? maxAttacks : attacks;
                    maxBonus = maxBonus > bonus ? maxBonus : bonus;
                    maxReact = maxReact > react ? maxReact : react;
                })
            }

        }

        // build the HTML with blank slate

        // populate the round

        // move to next round and determine how many participants (may change based on join_round property)
        // repeat

        // select all the html cells we need
        let cells = document.querySelectorAll(
            'div[data-round="1"] div[data-turn="1"]'
        );
        console.log(ctApp);
        // participants section

        cells[0].innerText = ctApp[0].AC;
        cells[1].innerText = ctApp[0].hpID;
        cells[2].innerText =
            ctApp[0].character_name +
            (ctApp[0].numeric_ID != null ? " #" + ctApp[0].numeric_ID : "");
        cells[3].innerText = ctApp[0].init;

        // first attack section
        let thisAction = turns[0];
        cells[4].innerText = thisAction.toolName;
        cells[5].innerText = thisAction.hit == 1 ? "X" : "";
        let thisTarget = ctApp.find((item) => item.pID == thisAction.targetID);
        cells[6].innerText =
            thisTarget.character_name +
            (thisTarget.numeric_ID != null ? " #" + thisTarget.numeric_ID : "");
        cells[7].innerText = thisAction.damage;

        // bonus attack
        thisAction = turns[1];
        cells[8].innerText = thisAction.toolName;
        cells[9].innerText = thisAction.hit == 1 ? "X" : "";
        thisTarget = ctApp.find((item) => item.pID == thisAction.targetID);
        cells[10].innerText =
            thisTarget.character_name +
            (thisTarget.numeric_ID != null ? " #" + thisTarget.numeric_ID : "");
        cells[11].innerText = thisAction.damage;
    }
</script>